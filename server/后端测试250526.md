
您对质量的要求非常高，我完全理解！追求卓越是我们的共同目标。让我们以百分之百的投入，再次深入剖析现有NFC中继系统的每一个角落，确保我们列出的功能点和测试点尽可能详尽无遗，并严格遵循最佳实践。

我们将把系统拆解到更细的粒度，对每个细微的功能行为都进行定义和测试规划。

**核心原则：**

*   **明确性 (Clarity):** 功能描述清晰，无歧义。
*   **完整性 (Completeness):** 尽可能覆盖所有已知代码路径和业务逻辑。
*   **可测性 (Testability):** 功能设计本身应易于测试，测试点具体可操作。
*   **隔离性 (Isolation):** 单元测试严格隔离被测单元，mock所有外部依赖。
*   **重复性 (Repeatability):** 测试结果稳定，不受外部环境干扰。
*   **自动化 (Automation):** 所有规划的测试最终都应是自动化的。

---

**NFC 中继系统：功能点与测试点 (深度剖析)**

**模块 0: 配置加载与管理**

*   **涉及文件:** `backend/config/nfc_relay.go`, `backend/config/config.go`, `backend/config.yaml`, `backend/global/config.go`, `backend/core/viper.go`
*   **核心功能:** 正确加载、解析并提供NFC中继相关的配置参数。

    *   **功能点 0.1:** `NfcRelay` 配置结构体定义 (`config/nfc_relay.go`)
        *   **子功能点 0.1.1:** 包含 `HubCheckIntervalSec` 字段。
        *   **子功能点 0.1.2:** 包含 `SessionInactiveTimeoutSec` 字段。
        *   **子功能点 0.1.3:** 包含 `WebsocketWriteWaitSec` 字段。
        *   **子功能点 0.1.4:** 包含 `WebsocketPongWaitSec` 字段。
        *   **子功能点 0.1.5:** 包含 `WebsocketMaxMessageBytes` 字段。
        *   **测试点 (代码审查/静态分析):**
            *   **类型:** 静态检查。
            *   **描述:** 验证结构体字段名、类型、`mapstructure`标签与`config.yaml`中键名一致。
            *   **断言:** 字段定义正确。

    *   **功能点 0.2:** `NfcRelay` 配置嵌入主配置 (`config.go`)
        *   **测试点 (代码审查/静态分析):**
            *   **类型:** 静态检查。
            *   **描述:** 验证 `Server` 结构体中正确嵌入了 `NfcRelay` 类型，并有正确的 `mapstructure` 标签。
            *   **断言:** 嵌入和标签正确。

    *   **功能点 0.3:** `config.yaml` 中 `nfc-relay` 配置块的解析
        *   **测试点 (集成测试 - Viper加载):**
            *   **类型:** 集成测试 (测试配置加载流程)。
            *   **场景 0.3.1:** `config.yaml` 包含所有 `nfc-relay` 字段且值为有效正整数。
                *   **Arrange:** 准备一个包含有效 `nfc-relay` 配置的 `config.yaml`。
                *   **Act:** 调用 `core.Viper()` (或模拟其核心逻辑) 加载配置。
                *   **Assert:** `global.GVA_CONFIG.NfcRelay` 中所有字段的值与 `config.yaml` 中的值匹配。
            *   **场景 0.3.2:** `config.yaml` 中 `nfc-relay` 字段缺失或值为无效类型/负数。
                *   **Arrange:** 准备包含无效/缺失 `nfc-relay` 配置的 `config.yaml`。
                *   **Act:** 加载配置。
                *   **Assert:** 验证系统是否有优雅的回退机制 (例如，使用默认值，或在后续使用配置处有默认值逻辑)，或者在关键配置缺失时启动失败/报错。 (目前系统在`client.go`和`hub.go`使用时有默认值回退)
            *   **场景 0.3.3:** `nfc-relay` 块完全缺失。
                *   **Arrange:** `config.yaml` 中无 `nfc-relay` 块。
                *   **Act:** 加载配置。
                *   **Assert:** `global.GVA_CONFIG.NfcRelay` 结构体为零值，后续使用配置的地方应有默认值处理。

**模块 1: WebSocket 客户端处理 (`backend/nfc_relay/handler/client.go`)**

*   **核心功能:** 管理单个客户端的WebSocket连接、数据收发、心跳维持和生命周期。

    *   **功能点 1.1:** `Client` 结构体定义
        *   **子功能点 1.1.1:** 包含 `hub *Hub` 引用。
        *   **子功能点 1.1.2:** 包含 `conn *websocket.Conn` 引用。
        *   **子功能点 1.1.3:** 包含 `send chan []byte` (带缓冲)。
        *   **子功能点 1.1.4:** 包含 `ID string` (UUID)。
        *   **子功能点 1.1.5:** 包含 `UserID string`。
        *   **子功能点 1.1.6:** 包含 `Authenticated bool`。
        *   **子功能点 1.1.7:** 包含 `CurrentRole protocol.RoleType`。
        *   **子功能点 1.1.8:** 包含 `IsOnline bool`。
        *   **子功能点 1.1.9:** 包含 `DisplayName string`。
        *   **子功能点 1.1.10:** 包含 `SessionID string`。
        *   **测试点 (代码审查):**
            *   **类型:** 静态检查。
            *   **描述:** 验证字段类型和用途的合理性。
            *   **断言:** 结构体定义符合预期。

    *   **功能点 1.2:** `NewClient(hub *Hub, conn *websocket.Conn)` 构造函数
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 1.2.1:** 成功创建新客户端。
                *   **Arrange:** 提供 mock `Hub` 和 mock `websocket.Conn`。
                *   **Act:** 调用 `NewClient()`。
                *   **Assert:**
                    *   返回的 `*Client` 实例不为 `nil`。
                    *   `client.hub` 指向传入的 `hub`。
                    *   `client.conn` 指向传入的 `conn`。
                    *   `client.send` 通道已创建且容量为256。
                    *   `client.ID` 是一个有效的UUID字符串。
                    *   其他字段（`UserID`, `Authenticated`等）为零值/默认值。

    *   **功能点 1.3:** `Client` 的 Getter 方法 (`GetID`, `GetRole` (旧), `GetSessionID`, `GetUserID`, `GetCurrentRole`)
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 1.3.1:** 各 Getter 返回正确的值。
                *   **Arrange:** 创建一个 `Client` 实例并手动设置其 `ID`, `SessionID`, `UserID`, `CurrentRole` 等字段。
                *   **Act:** 调用相应的 Getter 方法。
                *   **Assert:** 返回的值与设置的值相等。

    *   **功能点 1.4:** `Client.Send(message []byte) error` 方法 (实现 `ClientInfoProvider` 接口)
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 1.4.1:** 成功发送消息到 `send` 通道。
                *   **Arrange:** 创建 `Client`，其 `send` 通道未满且未关闭。准备一条消息。
                *   **Act:** 调用 `client.Send(message)`。
                *   **Assert:** 方法返回 `nil`错误。消息能从 `client.send` 通道中读出。
            *   **场景 1.4.2:** `send` 通道已满导致发送阻塞 (通过 `select default` 避免)。
                *   **Arrange:** 创建 `Client`，预先填满其 `send` 通道 (或使用无缓冲通道并使其阻塞)。
                *   **Act:** 在一个goroutine中尝试 `client.Send(message)` (如果直接调用会阻塞测试)。
                *   **Assert:** 方法应返回 `errors.New("failed to send message to client: channel full or closed")`。 (需要确保测试中不会死锁，可能需要超时机制)。
            *   **场景 1.4.3:** `send` 通道已关闭。
                *   **Arrange:** 创建 `Client`，关闭其 `send` 通道。
                *   **Act:** 调用 `client.Send(message)`。
                *   **Assert:** 方法应返回 `errors.New("failed to send message to client: channel full or closed")` (Go向已关闭通道发送数据会panic，但`select default`会捕获)。

    *   **功能点 1.5:** `Client.readPump()` 消息读取循环
        *   **依赖:** `websocket.Conn` (需mock), `Hub.unregister`, `Hub.processMessage`, `global.GVA_CONFIG.NfcRelay`。
        *   **测试点 (单元测试 - 较复杂，需要精细的 mock `websocket.Conn`):**
            *   **类型:** 单元测试 (使用 `gorilla/websocket` 的 mock 功能或自定义 mock)。
            *   **场景 1.5.1:** 成功读取文本消息。
                *   **Arrange:**
                    *   Mock `conn.ReadMessage()` 返回 `websocket.TextMessage`, 有效消息字节, `nil`错误。
                    *   Mock `conn.SetReadLimit()`, `conn.SetReadDeadline()`, `conn.SetPongHandler()`。
                    *   准备 mock `Hub` 并监听其 `processMessage` 和 `unregister` 通道。
                    *   `global.GVA_CONFIG.NfcRelay` 配置有效值。
                *   **Act:** 在 goroutine 中运行 `client.readPump()`。
                *   **Assert:**
                    *   `hub.processMessage` 收到包含该客户端和原始消息的 `ProcessableMessage`。
                    *   `hub.unregister` 未收到消息。
                    *   `conn.Close()` 未被调用 (在消息读取后)。
            *   **场景 1.5.2:** 收到 Pong 消息。
                *   **Arrange:** Mock `conn.SetPongHandler()` 的回调被触发。`conn.SetReadDeadline()` 被调用。
                *   **Act:** 模拟 Pong 消息的接收。
                *   **Assert:** `conn.SetReadDeadline()` 被以新的 `time.Now().Add(pongWait)` 参数调用。
            *   **场景 1.5.3:** 读取超时 (模拟 `conn.ReadMessage()` 返回超时错误)。
                *   **Arrange:** Mock `conn.ReadMessage()` 返回一个非 `websocket.IsUnexpectedCloseError` 的超时相关错误。
                *   **Act:** 运行 `client.readPump()`。
                *   **Assert:** `hub.unregister` 收到该客户端。 `conn.Close()` 被调用。
            *   **场景 1.5.4:** 客户端主动关闭连接 (例如 `websocket.CloseGoingAway`)。
                *   **Arrange:** Mock `conn.ReadMessage()` 返回 `websocket.CloseGoingAway` 错误。
                *   **Act:** 运行 `client.readPump()`。
                *   **Assert:** `hub.unregister` 收到该客户端。 `conn.Close()` 被调用。日志记录为 "WebSocket 连接由客户端关闭"。
            *   **场景 1.5.5:** 发生意外关闭错误。
                *   **Arrange:** Mock `conn.ReadMessage()` 返回一个被 `websocket.IsUnexpectedCloseError` 判断为真的错误。
                *   **Act:** 运行 `client.readPump()`。
                *   **Assert:** `hub.unregister` 收到该客户端。 `conn.Close()` 被调用。日志记录 "意外关闭错误"。
            *   **场景 1.5.6:** 消息超过 `maxMessageSize`。
                *   **Arrange:** Mock `conn.ReadMessage()` 返回因消息过大导致的错误 (需要查阅 `gorilla/websocket` 如何模拟此错误，或者 `SetReadLimit` 的行为)。
                *   **Act:** 运行 `client.readPump()`。
                *   **Assert:** 连接被关闭，客户端被注销，记录相应错误。
            *   **场景 1.5.7:** 收到二进制消息。
                *   **Arrange:** Mock `conn.ReadMessage()` 返回 `websocket.BinaryMessage`。
                *   **Act:** 运行 `client.readPump()`。
                *   **Assert:** 记录 "收到二进制消息" 日志，`hub.processMessage` 未收到消息。
            *   **场景 1.5.8:** `WebsocketPongWaitSec` 或 `WebsocketMaxMessageBytes` 配置为0或非法值。
                *   **Arrange:** 设置 `global.GVA_CONFIG.NfcRelay` 的相应字段为0。
                *   **Act:** 运行 `client.readPump()`。
                *   **Assert:** 使用了代码中的默认值 (例如 `maxMessageSize = 2048`)。

    *   **功能点 1.6:** `Client.writePump()` 消息写入循环
        *   **依赖:** `websocket.Conn` (需mock), `Client.send` channel, `global.GVA_CONFIG.NfcRelay`。
        *   **测试点 (单元测试 - 较复杂):**
            *   **类型:** 单元测试。
            *   **场景 1.6.1:** 成功从 `send` 通道取出消息并写入连接。
                *   **Arrange:**
                    *   Mock `conn.SetWriteDeadline()`, `conn.NextWriter()`, `writer.Write()`, `writer.Close()`.
                    *   `global.GVA_CONFIG.NfcRelay` 配置有效值。
                    *   向 `client.send` 通道发送一条消息。
                *   **Act:** 在 goroutine 中运行 `client.writePump()`。
                *   **Assert:** `conn.NextWriter()` 被调用，`writer.Write()` 被以消息内容调用，`writer.Close()` 被调用。
            *   **场景 1.6.2:** `send` 通道关闭。
                *   **Arrange:** 关闭 `client.send` 通道。
                *   **Act:** 运行 `client.writePump()`。
                *   **Assert:** `conn.WriteMessage(websocket.CloseMessage, ...)` 被调用。 `conn.Close()` 被调用。循环退出。
            *   **场景 1.6.3:** Ticker 触发发送 Ping 消息。
                *   **Arrange:** `global.GVA_CONFIG.NfcRelay.WebsocketPongWaitSec` 设置为较小值以加速 ticker。
                *   **Act:** 运行 `client.writePump()`，等待 ticker 触发。
                *   **Assert:** `conn.WriteMessage(websocket.PingMessage, nil)` 被调用。
            *   **场景 1.6.4:** 写入 WebSocket 连接失败 (e.g., `conn.NextWriter()` 或 `w.Write()` 或 `w.Close()` 返回错误)。
                *   **Arrange:** Mock 其中一个写入步骤返回错误。
                *   **Act:** 运行 `client.writePump()` (可能需要先发送一条消息到 `send` 通道)。
                *   **Assert:** `conn.Close()` 被调用。循环应退出或处理错误。记录相应错误。
            *   **场景 1.6.5:** 发送 Ping 失败。
                *   **Arrange:** Mock `conn.WriteMessage(websocket.PingMessage, nil)` 返回错误。
                *   **Act:** 运行 `client.writePump()` 等待 ticker。
                *   **Assert:** `conn.Close()` 被调用。循环应退出。记录错误。
            *   **场景 1.6.6:** `WebsocketWriteWaitSec` 或 `WebsocketPongWaitSec` 配置为0或非法值。
                 *   **Arrange:** 设置 `global.GVA_CONFIG.NfcRelay` 的相应字段为0。
                 *   **Act:** 运行 `client.writePump()`。
                 *   **Assert:** 使用了代码中的默认值 (例如 `pingPeriod = 54s` 当 `pongWait = 60s` 时)。

**模块 2: Hub 核心逻辑与客户端生命周期 (`backend/nfc_relay/handler/hub.go`)**

*   **核心功能:** 管理所有客户端的集合，处理客户端的注册/注销，路由消息。

    *   **功能点 2.1:** `Hub` 结构体定义
        *   **子功能点 2.1.1:** `clients map[*Client]bool`
        *   **子功能点 2.1.2:** `processMessage chan ProcessableMessage`
        *   **子功能点 2.1.3:** `register chan *Client`
        *   **子功能点 2.1.4:** `unregister chan *Client`
        *   **子功能点 2.1.5:** `sessions map[string]*session.Session`
        *   **子功能点 2.1.6:** `cardProviders map[string]session.ClientInfoProvider`
        *   **子功能点 2.1.7:** `providerListSubscribers map[string]map[*Client]bool`
        *   **子功能点 2.1.8:** `providerMutex sync.RWMutex`
        *   **测试点 (代码审查):** 字段类型和用途。

    *   **功能点 2.2:** `NewHub()` 构造函数
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 2.2.1:** 成功创建 Hub 实例。
                *   **Arrange:** 无。
                *   **Act:** `NewHub()`。
                *   **Assert:** 返回的 `*Hub` 实例不为 `nil`，所有 map 和 channel 都已初始化 (非nil)，互斥锁已初始化。

    *   **功能点 2.3:** `Hub.Run()` 事件循环 (核心逻辑)
        *   **依赖:** `Client`, `session.Session`, `global.GVA_CONFIG.NfcRelay`。
        *   **测试点 (集成测试为主，部分单元测试其 case 块的调用):**
            *   **类型:** 集成测试 (测试 Hub 的整体行为和与 Client 的交互)。
            *   **场景 2.3.1:** 处理客户端注册 (`case client := <-h.register`)。
                *   **Arrange:** 创建 mock `Client`，将其发送到 Hub 的 `register` 通道。
                *   **Act:** Hub 的 `Run()` 循环处理该消息 (需要运行 Hub 在 goroutine 中)。
                *   **Assert:**
                    *   `client` 被添加到 `h.clients` map中。
                    *   `ActiveConnections` 指标增加 (需 mock Prometheus Gauge)。
                    *   记录 "客户端已注册到 Hub" 日志。
            *   **场景 2.3.2:** 处理客户端注销 (`case client := <-h.unregister`)。
                *   **Arrange:** 先注册一个 mock `Client`，然后将其发送到 `unregister` 通道。Mock `client.send` 通道。
                *   **Act:** Hub 的 `Run()` 循环处理。
                *   **Assert:**
                    *   `client` 从 `h.clients` map中移除。
                    *   `client.send` 通道被关闭。
                    *   `ActiveConnections` 指标减少。
                    *   记录 "客户端已从 Hub 注销" 日志。
                    *   `h.handleClientDisconnect(client)` 被调用 (需验证其副作用，见模块7)。
            *   **场景 2.3.3:** 处理入站消息 (`case procMsg := <-h.processMessage`)。
                *   **Arrange:** 准备 `ProcessableMessage` (包含 mock `Client` 和消息字节)。将其发送到 `processMessage` 通道。
                *   **Act:** Hub 的 `Run()` 循环处理。
                *   **Assert:** `h.handleIncomingMessage(procMsg)` 被调用 (需验证其副作用，见后续模块)。
            *   **场景 2.3.4:** 定时检查不活动会话 (`case <-checkTicker.C`)。
                *   **Arrange:** `global.GVA_CONFIG.NfcRelay.HubCheckIntervalSec` 设置为较小值。
                *   **Act:** Hub 的 `Run()` 循环运行超过一个 `hubCheckInterval`。
                *   **Assert:** `h.checkInactiveSessions()` 被调用 (需验证其副作用，见模块7)。
            *   **场景 2.3.5:** `HubCheckIntervalSec` 配置为0或非法值。
                *   **Arrange:** 设置 `global.GVA_CONFIG.NfcRelay.HubCheckIntervalSec` 为0。
                *   **Act:** 运行 `Hub.Run()`。
                *   **Assert:** 使用默认的 `60 * time.Second` 间隔，并记录警告日志。

    *   **功能点 2.4:** `Hub.handleIncomingMessage(procMsg ProcessableMessage)` 消息分发
        *   **依赖:** `protocol` 消息类型, `Client.Authenticated`, `Client.UserID`, `Client.CurrentRole`。
        *   **测试点 (单元测试，mock 各种处理器方法):**
            *   **类型:** 单元测试。
            *   **场景 2.4.1:** 无效的通用消息 JSON 格式。
                *   **Arrange:** `procMsg.RawMessage` 为无效JSON。Mock `sendErrorMessage`。
                *   **Act:** 调用 `handleIncomingMessage()`。
                *   **Assert:**
                    *   `sendErrorMessage` 以 `protocol.ErrorCodeBadRequest` 调用。
                    *   记录 "反序列化通用消息失败" 错误日志。
                    *   记录 `error_occurred` 审计事件 (ErrorDetails: 无效的消息格式)。
            *   **场景 2.4.2:** 未认证客户端尝试发送非认证类型消息。
                *   **Arrange:** `procMsg.Client.Authenticated = false`。`procMsg.RawMessage` 解析为非 `ClientAuthMessage` 的类型。Mock `sendErrorMessage`。
                *   **Act:** 调用 `handleIncomingMessage()`。
                *   **Assert:**
                    *   `sendErrorMessage` 以 `protocol.ErrorCodeAuthRequired` 调用。
                    *   记录 "未认证的客户端尝试发送非认证消息" 警告日志。
                    *   记录 `error_occurred` 审计事件 (ErrorDetails: 请先进行认证)。
            *   **场景 2.4.3:** 分发到 `handleClientAuth`。
                *   **Arrange:** `procMsg.RawMessage` 解析为 `MessageTypeClientAuth`。Mock `h.handleClientAuth`。
                *   **Act:** 调用 `handleIncomingMessage()`。
                *   **Assert:** `h.handleClientAuth` 被以正确的 `client` 和 `messageBytes` 调用。
            *   **场景 2.4.4:** 分发到 `handleDeclareRole` (客户端已认证)。
                *   **Arrange:** `procMsg.Client.Authenticated = true`。`procMsg.RawMessage` 解析为 `MessageTypeDeclareRole`。Mock `h.handleDeclareRole`。
                *   **Act:** 调用 `handleIncomingMessage()`。
                *   **Assert:** `h.handleDeclareRole` 被调用。
            *   **场景 2.4.5:** 分发到 `handleListCardProviders` (客户端已认证，角色为 `receiver`)。
                *   **Arrange:** `procMsg.Client.Authenticated = true`, `procMsg.Client.CurrentRole = protocol.RoleReceiver`。`procMsg.RawMessage` 解析为 `MessageTypeListCardProviders`。Mock `h.handleListCardProviders`。
                *   **Act:** 调用 `handleIncomingMessage()`。
                *   **Assert:** `h.handleListCardProviders` 被调用。
            *   **场景 2.4.6:** 非 `receiver` 尝试 `ListCardProviders` (在 `handleListCardProviders` 内部处理，但 `handleIncomingMessage` 前置检查也可以有)。
                *   **Arrange:** `procMsg.Client.CurrentRole = protocol.RoleProvider`。`procMsg.RawMessage` 解析为 `MessageTypeListCardProviders`。Mock `sendErrorMessage`。
                *   **Act:** `handleIncomingMessage` -> `handleListCardProviders`。
                *   **Assert:** `sendErrorMessage` 被调用 (权限拒绝)。 (此检查主要在 `handleListCardProviders` 中)
            *   **场景 2.4.7 - 2.4.10:** 类似地测试分发到 `handleSelectCardProvider`, `handleAPDUUpstream`, `handleAPDUDownstream`, `handleEndSession`。确保认证和角色前置条件。
            *   **场景 2.4.11:** 收到不支持的消息类型。
                *   **Arrange:** `procMsg.RawMessage` 解析为未知类型。Mock `sendErrorMessage`。
                *   **Act:** 调用 `handleIncomingMessage()`。
                *   **Assert:**
                    *   `sendErrorMessage` 以 `protocol.ErrorCodeUnsupportedType` 调用。
                    *   记录 "Hub 收到未处理的消息类型" 警告日志。
                    *   记录 `error_occurred` 审计事件 (ErrorDetails: 不支持的消息类型)。

    *   **功能点 2.5:** `sendProtoMessage(client session.ClientInfoProvider, message interface{}) error` 辅助函数
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 2.5.1:** 成功序列化并发送消息。
                *   **Arrange:** Mock `ClientInfoProvider`，其 `Send()` 方法返回 `nil`。提供可序列化的 `message`。
                *   **Act:** 调用 `sendProtoMessage()`。
                *   **Assert:** `client.Send()` 被以序列化后的字节调用。返回 `nil` 错误。
            *   **场景 2.5.2:** 消息序列化失败。
                *   **Arrange:** Mock `ClientInfoProvider`。提供无法JSON序列化的 `message` (如含channel)。
                *   **Act:** 调用 `sendProtoMessage()`。
                *   **Assert:** 返回序列化错误。`client.Send()` 未被调用。记录 "序列化消息失败" 错误日志。
            *   **场景 2.5.3:** `client.Send()` 方法失败。
                *   **Arrange:** Mock `ClientInfoProvider`，其 `Send()` 方法返回一个错误。
                *   **Act:** 调用 `sendProtoMessage()`。
                *   **Assert:** 返回 `client.Send()` 的错误。记录 "通过接口发送消息给客户端失败" 警告日志。
            *   **场景 2.5.4:** `client` 参数为 `nil`。
                *   **Arrange:** `client` 为 `nil`。
                *   **Act:** 调用 `sendProtoMessage()`。
                *   **Assert:** 返回 `errors.New("client is nil")`。

    *   **功能点 2.6:** `sendErrorMessage(client session.ClientInfoProvider, code int, message string)` 辅助函数
        *   **依赖:** `sendProtoMessage`, `LogAuditEvent`, `HubErrors` metric。
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 2.6.1:** 成功构建并尝试发送错误消息。
                *   **Arrange:** Mock `ClientInfoProvider`。Mock `sendProtoMessage`。Mock `LogAuditEvent`。Mock `HubErrors.WithLabelValues().Inc()`。
                *   **Act:** 调用 `sendErrorMessage()`。
                *   **Assert:**
                    *   `LogAuditEvent` 被以 "client_error_notification_sent" 和正确的 `ErrorDetails` 及客户端信息调用。
                    *   `HubErrors` 指标被增加。
                    *   `sendProtoMessage` 被以构建的 `protocol.ErrorMessage` 调用。
            *   **场景 2.6.2:** `sendProtoMessage` 本身失败。
                *   **Arrange:** Mock `ClientInfoProvider`。Mock `sendProtoMessage` 返回错误。
                *   **Act:** 调用 `sendErrorMessage()`。
                *   **Assert:** 记录 "发送标准错误消息本身失败" 警告日志。
            *   **场景 2.6.3:** 客户端信息提取 (具体类型 `*Client` vs 接口)。
                *   **Arrange:** 传入具体 `*Client` 实例 (带 `UserID`, `SessionID`, `conn`) 和仅实现接口的 mock。
                *   **Act:** 调用 `sendErrorMessage()`。
                *   **Assert:** 审计日志的 `zap.Field` 中包含尽可能多的客户端信息。
好的，我们继续以这种极致详细的程度分析剩余的模块。

---

**模块 3: 客户端认证 (`backend/nfc_relay/handler/hub.go` - `handleClientAuth`)**

*   **核心功能:** 验证客户端提供的JWT，并据此更新客户端的认证状态和用户信息。

    *   **功能点 3.1:** 解析 `ClientAuthMessage`
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 3.1.1:** 成功解析合法的 `ClientAuthMessage` JSON。
                *   **Arrange:** 提供有效的 `ClientAuthMessage` JSON 字节。
                *   **Act:** 调用 `json.Unmarshal`。
                *   **Assert:** `authMsg` 结构体被正确填充，无错误。
            *   **场景 3.1.2:** 解析包含无效字段类型或结构的 `ClientAuthMessage` JSON。
                *   **Arrange:** 提供字段类型不匹配或结构错误的 JSON 字节。
                *   **Act:** 调用 `json.Unmarshal`。
                *   **Assert:** 返回 `json.UnmarshalTypeError` 或类似错误。
            *   **场景 3.1.3:** `rawMsg` 为格式错误的 JSON。
                *   **Arrange:** 提供无法解析为JSON的字节。Mock `sendErrorMessage`。
                *   **Act:** `handleClientAuth` 内部的 `json.Unmarshal`。
                *   **Assert:** `sendErrorMessage` 被以 `protocol.ErrorCodeBadRequest` ("Invalid auth message format") 调用。记录 "Error unmarshalling auth message" 错误日志。

    *   **功能点 3.2:** Token 存在性检查
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 3.2.1:** `authMsg.Token` 为空字符串。
                *   **Arrange:** `authMsg.Token = ""`。Mock `sendErrorMessage`。
                *   **Act:** 调用 `handleClientAuth`。
                *   **Assert:** `sendErrorMessage` 被以 `protocol.ErrorCodeAuthFailed` ("Token is missing") 调用。记录 "Token is missing in auth message" 警告日志。

    *   **功能点 3.3:** JWT 解析与验证 (使用 `utils.JWTService`)
        *   **依赖:** `utils.JWTService` (应 mock 其 `ParseToken` 方法)。
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 3.3.1:** `ParseToken` 返回有效 `claims` (包含有效的 `BaseClaims.ID`)。
                *   **Arrange:** Mock `jwtService.ParseToken` 返回有效的 `*request.CustomClaims` 和 `nil` 错误。Mock `client` (待更新字段)。Mock `LogAuditEvent` 和 `AuthEvents` 指标。Mock `sendProtoMessage`。
                *   **Act:** 调用 `handleClientAuth`。
                *   **Assert:**
                    *   `client.Authenticated` 变为 `true`。
                    *   `client.UserID` 被设置为 `claims.BaseClaims.ID` 的字符串形式。
                    *   `sendProtoMessage` 被以 `ServerAuthResponseMessage{Success: true, UserID: ...}` 调用。
                    *   `AuthEvents.WithLabelValues("success", "").Inc()` 被调用。
                    *   `LogAuditEvent` 被以 "auth_success" 调用 (现在已移到 Prometheus 指标处，但原始设计有)。
                    *   记录 "Client authenticated successfully" Info 日志。
            *   **场景 3.3.2:** `ParseToken` 返回 `utils.TokenExpired` 错误。
                *   **Arrange:** Mock `jwtService.ParseToken` 返回 `nil, utils.TokenExpired`。Mock `sendErrorMessage`。Mock `AuthEvents` 指标。
                *   **Act:** 调用 `handleClientAuth`。
                *   **Assert:** `sendErrorMessage` 被以 `protocol.ErrorCodeAuthFailed` ("Token has expired") 调用。`AuthEvents.WithLabelValues("failure", "Token has expired").Inc()` 被调用。记录 "Token validation failed" 警告日志。
            *   **场景 3.3.3 - 3.3.7:** 类似地测试 `TokenNotValidYet`, `TokenMalformed`, `TokenSignatureInvalid`, `TokenInvalid` 及其他通用解析错误。
                *   **Assert:** 对应的错误消息和指标标签被使用。
            *   **场景 3.3.8:** `ParseToken` 返回有效 `claims` 但 `claims.BaseClaims.ID` 为 0 (或 `claims` / `BaseClaims` 为 `nil`)。
                *   **Arrange:** Mock `jwtService.ParseToken` 返回 `claims` 其 `BaseClaims.ID = 0`。Mock `sendErrorMessage`。Mock `AuthEvents` 指标。
                *   **Act:** 调用 `handleClientAuth`。
                *   **Assert:** `sendErrorMessage` 被以 `protocol.ErrorCodeAuthFailed` ("UserID missing or invalid in token") 调用。`AuthEvents.WithLabelValues("failure", "UserID missing or invalid in token").Inc()` 被调用。记录 "UserID is missing in token claims" 错误日志。

    *   **功能点 3.4:** 并发保护
        *   **测试点 (集成/压力测试):**
            *   **类型:** 集成测试。
            *   **场景 3.4.1:** 多个客户端并发进行认证。
                *   **Arrange:** 启动 Hub，多个 mock 客户端并发发送认证请求。
                *   **Act:** Hub 处理这些请求。
                *   **Assert:** `h.providerMutex` 正确保护了对 `client` 字段 (如 `Authenticated`, `UserID`) 的并发写。无数据竞争 (通过 `-race` 标志检测)。每个客户端的认证结果正确。

---

**模块 4: 角色声明与状态管理 (`backend/nfc_relay/handler/hub.go` - `handleDeclareRole`)**

*   **核心功能:** 允许认证后的客户端声明其角色 (provider/receiver/none)，在线状态，以及 provider 的显示名称，并据此更新 Hub 的内部状态和通知相关方。

    *   **功能点 4.1:** 解析 `DeclareRoleMessage`
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 4.1.1:** 成功解析合法的 `DeclareRoleMessage` JSON。
                *   **Assert:** `declareMsg` 被正确填充。
            *   **场景 4.1.2:** `rawMsg` 为格式错误的 JSON。
                *   **Assert:** `sendErrorMessage` 被以 `protocol.ErrorCodeBadRequest` ("Invalid declare role message format") 调用。记录 "Error unmarshalling declare role message" 错误日志。

    *   **功能点 4.2:** 角色有效性验证
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 4.2.1:** `declareMsg.Role` 为无效值 (非 "provider", "receiver", "none")。
                *   **Arrange:** `declareMsg.Role = "invalid_role"`。Mock `sendErrorMessage`。
                *   **Act:** 调用 `handleDeclareRole`。
                *   **Assert:** `sendErrorMessage` 被以 `protocol.ErrorCodeBadRequest` ("Invalid role specified") 调用。记录 "Invalid role in DeclareRoleMessage" 警告日志。

    *   **功能点 4.3:** 更新客户端状态 (`CurrentRole`, `IsOnline`, `DisplayName`)
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 4.3.1:** 声明为 `provider`, `Online=true`, 提供 `ProviderName`。
                *   **Arrange:** Mock `client`。`declareMsg = {Role: "provider", Online: true, ProviderName: "MyCard"}`。
                *   **Act:** 调用 `handleDeclareRole`。
                *   **Assert:** `client.CurrentRole` 为 `"provider"`, `client.IsOnline` 为 `true`, `client.DisplayName` 为 `"MyCard"`。
            *   **场景 4.3.2:** 声明为 `provider`, `Online=true`, 未提供 `ProviderName` (首次声明或之前 `DisplayName` 为空)。
                *   **Arrange:** `client.DisplayName = ""`. `declareMsg = {Role: "provider", Online: true, ProviderName: ""}`.
                *   **Assert:** `client.DisplayName` 被设置为默认名称 (如 "Default Provider " + clientID前缀)。
            *   **场景 4.3.3:** 声明为 `provider`, `Online=true`, 未提供 `ProviderName` (但之前已有 `DisplayName`)。
                *   **Arrange:** `client.DisplayName = "OldName"`. `declareMsg = {Role: "provider", Online: true, ProviderName: ""}`.
                *   **Assert:** `client.DisplayName` 保持为 `"OldName"`。
            *   **场景 4.3.4:** 声明为 `receiver`。
                *   **Arrange:** `declareMsg = {Role: "receiver", Online: true}` (Online对receiver意义不大但消息中可带)。
                *   **Assert:** `client.CurrentRole` 为 `"receiver"`, `client.DisplayName` 被清空 (如果之前是provider)。
            *   **场景 4.3.5:** 声明为 `none`。
                *   **Assert:** `client.CurrentRole` 为 `"none"`, `client.DisplayName` 被清空。

    *   **功能点 4.4:** `cardProviders` 映射管理
        *   **测试点 (单元测试, mock `h.notifyProviderListSubscribers`):**
            *   **类型:** 单元测试。
            *   **场景 4.4.1:** 新 `provider` 上线 (`Role="provider"`, `Online=true`)。
                *   **Arrange:** `client` 之前不是 `provider` 或不在线。
                *   **Act:** `handleDeclareRole`。
                *   **Assert:** `client` (作为 `ClientInfoProvider`) 被添加到 `h.cardProviders` (key为 `client.GetID()`)。记录 "Provider declared and online" 日志。`h.notifyProviderListSubscribers(client.GetUserID())` 被调用。
            *   **场景 4.4.2:** 已有 `provider` 下线 (`Role="provider"`, `Online=false`)。
                *   **Arrange:** `client` 已在 `h.cardProviders` 中。
                *   **Act:** `handleDeclareRole` (声明为 offline provider)。
                *   **Assert:** `client` 从 `h.cardProviders` 移除。记录 "Provider declared offline" 日志。`h.notifyProviderListSubscribers(client.GetUserID())` 被调用。
            *   **场景 4.4.3:** `provider` 更改角色为 `receiver` 或 `none`。
                *   **Arrange:** `client` 原为 `provider` 且在线，在 `h.cardProviders` 中。
                *   **Act:** `handleDeclareRole` (声明为新角色)。
                *   **Assert:** `client` 从 `h.cardProviders` 移除。记录 "Client changed role from provider, removed from list" 日志。`h.notifyProviderListSubscribers(client.GetUserID())` 被调用。
            *   **场景 4.4.4:** 非 `provider` 角色声明不影响 `cardProviders` (除非之前是provider)。
                *   **Arrange:** `client` 角色为 `receiver`。
                *   **Act:** `handleDeclareRole` (再次声明为 `receiver` 或 `none`)。
                *   **Assert:** `h.cardProviders` 不变 (除非该client之前是provider并被移除)。`h.notifyProviderListSubscribers` 不应因此调用(除非是旧provider移除)。

    *   **功能点 4.5:** 发送 `RoleDeclaredResponseMessage`
        *   **测试点 (单元测试, mock `sendProtoMessage`):**
            *   **类型:** 单元测试。
            *   **场景 4.5.1:** 成功发送响应。
                *   **Arrange:** Mock `sendProtoMessage` 返回 `nil`。
                *   **Act:** 调用 `handleDeclareRole`。
                *   **Assert:** `sendProtoMessage` 被以正确的 `RoleDeclaredResponseMessage` (包含更新后的 `Role` 和 `Online` 状态) 调用。
            *   **场景 4.5.2:** 发送响应失败。
                *   **Arrange:** Mock `sendProtoMessage` 返回错误。
                *   **Act:** `handleDeclareRole`。
                *   **Assert:** 记录 "Failed to send role declared response" 错误日志。

    *   **功能点 4.6:** 调用 `notifyProviderListSubscribers` 的条件判断
        *   **测试点 (单元测试, mock `notifyProviderListSubscribers`):**
            *   **类型:** 单元测试。
            *   **场景 4.6.1:** `provider` 上线 -> `notify` 调用。
            *   **场景 4.6.2:** `provider` 下线 -> `notify` 调用。
            *   **场景 4.6.3:** `provider` 角色变更为非 `provider` -> `notify` 调用。
            *   **场景 4.6.4:** `receiver` 状态变化 -> `notify` *不*应因此调用。
            *   **场景 4.6.5:** `provider` 仅更新 `ProviderName` (角色和在线状态不变) -> `notify` *不*应因此调用 (当前逻辑是这样，如果需要名称变化也通知，则逻辑需改)。
            *   **Arrange & Act & Assert:** 通过设置 `client` 的 `oldRole`, `oldIsOnline` 和传入的 `declareMsg` 来模拟各种状态转换，验证 `h.notifyProviderListSubscribers(client.GetUserID())` 是否按预期被调用。

    *   **功能点 4.7:** 并发保护
        *   **测试点 (集成测试):**
            *   **类型:** 集成测试。
            *   **场景 4.7.1:** 多个客户端并发声明角色。
                *   **Assert:** `h.providerMutex` 正确保护对 `client` 字段、`h.cardProviders`、`h.providerListSubscribers` 的并发访问。无数据竞争。最终状态正确。
好的，我们继续！以百分之百的投入，完成所有模块的深度剖析。

---

**模块 5: 发卡方列表与订阅 (`backend/nfc_relay/handler/hub.go` - `handleListCardProviders`, `notifyProviderListSubscribers`)**

*   **核心功能:** 允许 `receiver` 客户端获取同 `UserID` 下可用的 `provider` 列表，并订阅该列表的更新。

    *   **功能点 5.1:** `handleListCardProviders` - 处理列表请求
        *   **依赖:** `Client.CurrentRole`, `Client.Authenticated`, `Client.UserID`, `h.providerListSubscribers`, `h.cardProviders`, `h.sessions`, `sendErrorMessage`, `sendProtoMessage`。
        *   **测试点 (单元测试, mock 依赖):**
            *   **类型:** 单元测试。
            *   **场景 5.1.1:** 非 `receiver` (也不是空角色) 客户端请求列表 (权限检查)。
                *   **Arrange:** `requestingClient.CurrentRole = "provider"`。Mock `sendErrorMessage`。
                *   **Act:** `handleListCardProviders()`。
                *   **Assert:** `sendErrorMessage` 被以 "只有收卡方角色才能获取发卡方列表" (或类似) 调用。
            *   **场景 5.1.2:** 解析 `ListCardProvidersMessage` 失败。
                *   **Arrange:** `messageBytes` 为无效 JSON。Mock `sendErrorMessage`。
                *   **Assert:** `sendErrorMessage` 被以 `protocol.ErrorCodeBadRequest` ("无效的列表请求消息格式") 调用。记录错误日志。
            *   **场景 5.1.3:** 成功将请求客户端添加到其 `UserID` 的 `providerListSubscribers`。
                *   **Arrange:** `requestingClient` 已认证且有 `UserID`。`h.providerListSubscribers` 初始为空或不包含此 `UserID`。
                *   **Assert:** `h.providerListSubscribers[requestingClient.UserID][requestingClient]` 为 `true`。记录 Debug 日志。
            *   **场景 5.1.4:** 筛选并构建 `availableProviders` 列表:
                *   **子场景 5.1.4.1:** 存在多个同 `UserID` 的在线 `provider`，部分空闲，部分繁忙。
                    *   **Arrange:** 准备 `h.cardProviders` 和 `h.sessions` 数据。确保 `provider` 的 `DisplayName` 已设置或能回退。
                    *   **Assert:** `availableProviders` 列表包含所有正确的 `provider` 信息 (`ProviderID`, `ProviderName`, `UserID`, 正确的 `IsBusy` 状态)。
                *   **子场景 5.1.4.2:** 不存在与请求者 `UserID` 匹配的 `provider`。
                    *   **Assert:** `availableProviders` 为空列表。
                *   **子场景 5.1.4.3:** `provider` 的 `DisplayName` 为空，使用后备名称。
                    *   **Assert:** `ProviderName` 为 "Provider " + ID前缀。
                *   **子场景 5.1.4.4:** `h.cardProviders` 中的条目不是 `*Client` 类型 (异常情况)。
                    *   **Arrange:** (较难直接arrange，但需要代码有健壮性) 如果 `providerClient.(*Client)` 类型断言失败。
                    *   **Assert:** 行为应可控，例如跳过该条目或记录错误，而不是panic。当前代码会使用 "Provider " + ID前缀作为名字，但如果类型完全不对， `GetID()` 等方法可能也会出问题。
            *   **场景 5.1.5:** 成功发送 `CardProvidersListMessage` 给请求客户端。
                *   **Arrange:** Mock `sendProtoMessage` 返回 `nil`。
                *   **Assert:** `sendProtoMessage` 被以正确的 `CardProvidersListMessage` 调用。记录 Info 日志。
            *   **场景 5.1.6:** 发送 `CardProvidersListMessage` 失败。
                *   **Arrange:** Mock `sendProtoMessage` 返回错误。
                *   **Assert:** 记录 "向请求列表的客户端发送列表失败" 错误日志。
            *   **场景 5.1.7:** 并发处理列表请求。
                *   **Assert:** `h.providerMutex.Lock()` (或 `RLock`) 保护了对 `h.providerListSubscribers` 和 `h.cardProviders` 的并发访问。

    *   **功能点 5.2:** `notifyProviderListSubscribers(targetUserID string)` - 通知订阅者列表更新
        *   **依赖:** `h.providerListSubscribers`, `h.cardProviders`, `h.sessions`, `sendProtoMessage`。
        *   **测试点 (单元测试, mock 依赖):**
            *   **类型:** 单元测试。
            *   **场景 5.2.1:** `targetUserID` 没有订阅者。
                *   **Arrange:** `h.providerListSubscribers[targetUserID]` 不存在或为空。
                *   **Act:** `notifyProviderListSubscribers(targetUserID)`。
                *   **Assert:** 函数应提前返回，不执行后续逻辑，不发送消息。
            *   **场景 5.2.2:** 成功为 `targetUserID` 的所有订阅者构建并发送更新的 `CardProvidersListMessage`。
                *   **Arrange:**
                    *   `h.providerListSubscribers[targetUserID]` 包含多个 mock `Client` (作为订阅者)。
                    *   `h.cardProviders` 和 `h.sessions` 包含 `targetUserID` 下的 `provider` (不同繁忙状态)。
                    *   Mock `sendProtoMessage`。
                *   **Act:** `notifyProviderListSubscribers(targetUserID)`。
                *   **Assert:**
                    *   为每个订阅者都调用了 `sendProtoMessage`，发送的 `CardProvidersListMessage` 内容基于当前最新的 `h.cardProviders` 和 `h.sessions` 状态。
                    *   `provider` 的 `DisplayName` 和 `IsBusy` 状态正确。
                    *   记录 Info 日志 "Notified subscribers..."。
            *   **场景 5.2.3:** 向某个订阅者发送消息失败。
                *   **Arrange:** Mock `sendProtoMessage` 对特定订阅者返回错误。
                *   **Act:** `notifyProviderListSubscribers(targetUserID)`。
                *   **Assert:** 记录 "Failed to send provider list to subscriber" 错误日志。不影响向其他订阅者发送。
            *   **场景 5.2.4:** `providerEntry` 不是 `*Client` 类型 (异常情况)。
                *   **Arrange:** 模拟 `h.cardProviders` 中存在非 `*Client` 条目 (如果可能)。
                *   **Act:** `notifyProviderListSubscribers(targetUserID)`。
                *   **Assert:** 记录 "providerEntry is not of type *Client" 错误日志，并使用回退名称。
            *   **场景 5.2.5:** `notifyProviderListSubscribers` 被异步调用 (如 `go h.notifyProviderListSubscribers(...)`)。
                *   **测试点 (集成测试关注点):** 确保异步调用不会导致数据竞争或过早释放锁导致数据不一致 (当前设计中，通知方法内部使用读锁)。

---

**模块 6: 会话建立 (`backend/nfc_relay/handler/hub.go` - `handleSelectCardProvider`)**

*   **核心功能:** 允许 `receiver` 选择一个可用的 `provider` 来建立一个新的 NFC 中继会话。

    *   **功能点 6.1:** 解析 `SelectCardProviderMessage`
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 6.1.1:** 成功解析合法的 `SelectCardProviderMessage` JSON。
            *   **场景 6.1.2:** `rawMsg` 为格式错误的 JSON。
                *   **Assert:** `sendErrorMessage` (ErrorCodeBadRequest, "无效的选择发卡方消息格式")。

    *   **功能点 6.2:** 前置条件检查 (获取读锁 `h.providerMutex.RLock()` 期间)
        *   **测试点 (单元测试, mock `h.cardProviders`, `h.sessions`, `sendErrorMessage`):**
            *   **类型:** 单元测试。
            *   **场景 6.2.1:** 请求者非 `receiver` 角色。
                *   **Assert:** `sendErrorMessage` (ErrorCodePermissionDenied, "操作失败：只有 receiver...").
            *   **场景 6.2.2:** `ProviderID` 为空。
                *   **Assert:** `sendErrorMessage` (ErrorCodeBadRequest, "选择发卡方失败：必须提供有效的 ProviderID。").
            *   **场景 6.2.3:** 目标 `provider` 不存在或未上线 (不在 `h.cardProviders`)。
                *   **Assert:** `sendErrorMessage` (ErrorCodeProviderNotFound, "目标发卡方不存在...").
            *   **场景 6.2.4:** `h.cardProviders` 中的条目不是 `*Client` 类型 (异常)。
                *   **Assert:** `sendErrorMessage` (ErrorCodeInternalError, "服务器内部错误。").
            *   **场景 6.2.5:** 请求者和提供者 `UserID` 不匹配。
                *   **Assert:** `sendErrorMessage` (ErrorCodePermissionDenied, "不能选择其他账户下的发卡方。").
            *   **场景 6.2.6:** 请求者选择自己作为 `provider`。
                *   **Assert:** `sendErrorMessage` (ErrorCodeSelectSelf, "不能选择自己。").
            *   **场景 6.2.7:** 请求者 (`receiver`) 当前已在会话中 (通过 `requestingClient.GetSessionID()` 和 `h.sessions` 检查)。
                *   **Assert:** `sendErrorMessage` (ErrorCodeReceiverBusy, "您当前已在会话中。").
            *   **场景 6.2.8:** 目标 `provider` 当前已在会话中 (通过 `targetProviderConcrete.GetSessionID()` 和 `h.sessions` 检查)。
                *   **Assert:** `sendErrorMessage` (ErrorCodeProviderBusy, "目标发卡方当前正忙。").

    *   **功能点 6.3:** 会话创建与状态更新 (获取写锁 `h.providerMutex.Lock()` 之后)
        *   **依赖:** `uuid.NewString()`, `session.NewSession()`, `activeSession.SetClient()`, `sendProtoMessage`, `LogAuditEvent`, `ActiveSessions` metric, `h.notifyProviderListSubscribers`。
        *   **测试点 (单元测试, mock 依赖):**
            *   **类型:** 单元测试。
            *   **场景 6.3.1:** **双重检查失败** - 在释放读锁和获取写锁之间，`provider` 状态改变 (如下线、被他人选择、UserID改变等)。
                *   **Arrange:** 在 `h.providerMutex.RLock()` 检查通过后，但在 `h.providerMutex.Lock()` 逻辑执行前，修改 `h.cardProviders` 或 `requestingClient`/`targetProvider` 的 `SessionID` 来模拟状态变化。
                *   **Act:** `handleSelectCardProvider()` 继续执行。
                *   **Assert:** `sendErrorMessage` 被以 `ErrorCodeProviderUnavailable` 或 `ErrorCodeSessionConflict` 调用。会话未创建。
            *   **场景 6.3.2:** 成功创建新会话。
                *   **Arrange:** 所有检查通过。Mock `session.NewSession()` 返回 mock `Session`。Mock `sendProtoMessage`, `LogAuditEvent`, `ActiveSessions.Inc()`, `h.notifyProviderListSubscribers`。
                *   **Act:** `handleSelectCardProvider()`。
                *   **Assert:**
                    *   `session.NewSession` 被调用。
                    *   `newSession.SetClient` 被为 `requestingClient` (receiver) 和 `targetProvider` (provider) 调用。
                    *   新会Session被添加到 `h.sessions` (key为生成的 sessionID)。
                    *   `requestingClient.SessionID` 和 `targetProviderConcrete.SessionID` 被更新为新 sessionID。
                    *   `LogAuditEvent` 被以 "session_established" 和正确的 `SessionDetails` 及参与者信息调用。
                    *   `ActiveSessions.Inc()` 被调用。
                    *   `sendProtoMessage` 被为 `requestingClient` 和 `targetProvider` 调用，发送 `SessionEstablishedMessage` (包含正确的 `PeerID` 和 `PeerRole`)。
                    *   `h.notifyProviderListSubscribers(targetProviderConcrete.GetUserID())` 被调用 (因为 provider 变忙)。
                    *   记录 "Receiver selected provider, new session created..." Info 日志。
            *   **场景 6.3.3:** `sendProtoMessage` 通知任一方失败。
                *   **Arrange:** Mock `sendProtoMessage` 对 `receiver` 或 `provider` 返回错误。
                *   **Assert:** 记录相应的 "发送会话建立成功的消息给...失败" 错误日志。 (当前实现：会话仍然建立，只记录错误。可讨论是否需要回滚。)

    *   **功能点 6.4:** 并发会话建立
        *   **测试点 (集成测试):**
            *   **类型:** 集成测试。
            *   **场景 6.4.1:** 多个 `receiver` 并发尝试选择同一个空闲 `provider`。
                *   **Arrange:** 启动 Hub，一个空闲 `provider`，多个 `receiver`。
                *   **Act:** `receiver` 并发发送选择请求。
                *   **Assert:** 只有一个 `receiver` 成功建立会话。其他 `receiver` 收到 `ErrorCodeProviderBusy` 或 `ErrorCodeSessionConflict`。`h.providerMutex` 保证了操作的原子性。无数据竞争。
            *   **场景 6.4.2:** 同一个 `receiver` 快速连续发送多个选择不同 `provider` 的请求 (如果第一个成功，第二个应失败)。
                *   **Assert:** 第一个请求成功后，`receiver` 状态变为繁忙，第二个请求应因 `ErrorCodeReceiverBusy` 失败。

---

**模块 7: APDU 中继 (`backend/nfc_relay/handler/hub.go` - `handleAPDUExchange`)**

*   **核心功能:** 在已建立的会话中，安全、可靠地中继 APDU 消息，并更新会话活动状态。

    *   **功能点 7.1:** 前置条件检查
        *   **依赖:** `sourceClient.SessionID`, `h.sessions`, `activeSession.GetPeer()`.
        *   **测试点 (单元测试, mock 依赖):**
            *   **类型:** 单元测试。
            *   **场景 7.1.1:** `sourceClient.SessionID` 为空。
                *   **Arrange:** `sourceClient.SessionID = ""`。Mock `sendErrorMessage`。
                *   **Act:** `handleAPDUExchange()`。
                *   **Assert:** `sendErrorMessage` ("您当前不在任何APDU中继会话中...")。记录警告日志。
            *   **场景 7.1.2:** `sourceClient.SessionID` 有效，但会话在 `h.sessions` 中不存在。
                *   **Arrange:** `sourceClient.SessionID = "valid_but_gone_session"`，`h.sessions` 中无此key。Mock `sendErrorMessage`。
                *   **Act:** `handleAPDUExchange()`。
                *   **Assert:** `sourceClient.SessionID` 被清空。`sendErrorMessage` ("您当前的APDU会话已失效...")。记录错误日志。
            *   **场景 7.1.3:** 会话存在，但 `activeSession.GetPeer(sourceClient)` 返回 `nil` (对端丢失)。
                *   **Arrange:** Mock `activeSession.GetPeer()` 返回 `nil`。Mock `sendErrorMessage`。
                *   **Act:** `handleAPDUExchange()`。
                *   **Assert:** `sendErrorMessage` ("APDU发送失败：未能找到您的通信对端")。记录警告日志。 (当前实现：不自动终止会话，可讨论)

    *   **功能点 7.2:** 会话活动时间更新
        *   **依赖:** `activeSession.UpdateActivityTime()`.
        *   **测试点 (单元测试, mock `activeSession`):**
            *   **类型:** 单元测试。
            *   **场景 7.2.1:** 成功调用 `UpdateActivityTime`。
                *   **Arrange:** Mock `activeSession.UpdateActivityTime()`。
                *   **Act:** 在 `handleAPDUExchange` 的有效路径中。
                *   **Assert:** `activeSession.UpdateActivityTime()` 被调用一次。

    *   **功能点 7.3:** APDU 消息解析 (Upstream/Downstream)
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 7.3.1:** 解析合法的 `APDUUpstreamMessage` (direction="upstream")。
                *   **Arrange:** `messageBytes` 为有效 `APDUUpstreamMessage` JSON。
                *   **Assert:** `apduData` 被正确提取，`targetMessageType` (虽未使用但被设置) 为 `protocol.MessageTypeAPDUToCard`。记录 Info 日志。
            *   **场景 7.3.2:** 解析合法的 `APDUDownstreamMessage` (direction="downstream")。
                *   **Arrange:** `messageBytes` 为有效 `APDUDownstreamMessage` JSON。
                *   **Assert:** `apduData` 被正确提取，`targetMessageType` 为 `protocol.MessageTypeAPDUFromCard`。记录 Info 日志。
            *   **场景 7.3.3:** 解析失败 (无效JSON)。
                *   **Arrange:** `messageBytes` 为无效JSON。Mock `sendErrorMessage`。
                *   **Assert:** `sendErrorMessage` ("无效的APDU消息格式...")。记录错误日志。
            *   **场景 7.3.4:** 未知的 `direction` (理论上不应发生，因调用时已指定)。
                *   **Arrange:** (如果可构造) `direction` 为其他值。
                *   **Assert:** 记录 "未知的APDU方向" 错误日志。函数提前返回。

    *   **功能点 7.4:** APDU 中继尝试审计与日志
        *   **依赖:** `LogAuditEvent`.
        *   **测试点 (单元测试, mock `LogAuditEvent`):**
            *   **类型:** 单元测试。
            *   **场景 7.4.1:** 记录 APDU 中继尝试。
                *   **Arrange:** 设置 `sourceClient`, `peerClient` 等上下文。
                *   **Act:** `handleAPDUExchange()` 中调用 `LogAuditEvent`。
                *   **Assert:** `LogAuditEvent` 被以 "apdu_relayed_attempt", 正确的 `APDUDetails` (direction, length), 及会话/客户端信息调用。

    *   **功能点 7.5:** APDU 消息转发给对端
        *   **依赖:** `peerClient.Send()`.
        *   **测试点 (单元测试, mock `peerClient`):**
            *   **类型:** 单元测试。
            *   **场景 7.5.1:** `peerClient.Send(messageBytes)` 成功。
                *   **Arrange:** Mock `peerClient.Send()` 返回 `nil`。Mock `ApduMessagesRelayed` 指标, `LogAuditEvent` (success)。
                *   **Act:** `handleAPDUExchange()`。
                *   **Assert:**
                    *   `peerClient.Send()` 被以原始 `messageBytes` 调用。
                    *   `ApduMessagesRelayed.WithLabelValues(direction, sessionID).Inc()` 被调用。
                    *   `LogAuditEvent` 被以 "apdu_relayed_success" 和正确的 `APDUDetails` 调用。
                    *   记录 "APDU 消息已成功转发" Info 日志。
            *   **场景 7.5.2:** `peerClient.Send(messageBytes)` 失败。
                *   **Arrange:** Mock `peerClient.Send()` 返回错误。Mock `sendErrorMessage`。Mock `ApduRelayErrors` 指标。Mock `LogAuditEvent` (failure)。Mock `h.terminateSessionByID`。
                *   **Act:** `handleAPDUExchange()`。
                *   **Assert:**
                    *   `sendErrorMessage` 被以 `protocol.ErrorCodeMessageSendFailed` 和错误信息调用，发送给 `sourceClient`。
                    *   `ApduRelayErrors.WithLabelValues(direction, sessionID).Inc()` 被调用。
                    *   `LogAuditEvent` 被以 "apdu_relayed_failure" 和正确的 `ErrorDetails` 调用。
                    *   `h.terminateSessionByID(sourceClient.SessionID, "APDU转发失败导致会话终止", sourceClient.GetID(), sourceClient.GetUserID())` 被调用。

    *   **功能点 7.6:** 并发 APDU 交换
        *   **测试点 (集成测试):**
            *   **类型:** 集成测试。
            *   **场景 7.6.1:** 会话中的双方客户端并发发送 APDU 消息。
                *   **Arrange:** 建立一个会话，两个 mock 客户端。
                *   **Act:** 并发调用 `handleAPDUExchange` (模拟从不同客户端收到消息)。
                *   **Assert:** 消息被正确转发给各自的对端。`h.providerMutex` 的读锁 (`RLock`) 允许多个会话的 APDU 并发读取 `h.sessions`，但单个会话内的 APDU 处理是顺序的（由客户端的 `processMessage` 串行化）。无数据竞争。

---

**模块 8: 会话终止与清理 (`backend/nfc_relay/handler/hub.go` - `handleEndSession`, `terminateSessionByID`, `handleClientDisconnect`, `checkInactiveSessions`)**

*   **核心功能:** 处理会话的各种终止场景 (主动请求、客户端断开、超时、错误)，并执行相应的清理和通知。

    *   **功能点 8.1:** `handleEndSession` - 客户端主动请求结束会话
        *   **依赖:** `Client.SessionID`, `h.terminateSessionByID`, `sendProtoMessage` (for confirmation).
        *   **测试点 (单元测试, mock 依赖):**
            *   **类型:** 单元测试。
            *   **场景 8.1.1:** 解析 `EndSessionMessage` 失败。
                *   **Assert:** `sendErrorMessage` (ErrorCodeBadRequest, "无效的结束会话消息格式")。
            *   **场景 8.1.2:** 请求的 `SessionID` 与客户端实际 `SessionID` 不匹配或为空。
                *   **Arrange:** `endMsg.SessionID != requestingClient.SessionID`。Mock `sendErrorMessage`。
                *   **Assert:** `sendErrorMessage` ("无法结束指定的会话：ID不匹配或无效")。记录警告日志。
            *   **场景 8.1.3:** 成功请求结束会话。
                *   **Arrange:** `endMsg.SessionID == requestingClient.SessionID`。Mock `h.terminateSessionByID`。Mock `sendProtoMessage`。
                *   **Assert:**
                    *   `h.terminateSessionByID(targetSessionID, "客户端主动请求结束", requestingClientID, requestingClientUserID)` 被调用。
                    *   `sendProtoMessage` 被调用向 `requestingClient` 发送 `SessionTerminatedMessage` (Reason: "您已成功结束会话") 作为确认。
                    *   记录 Info 日志 "客户端请求结束会话..."。

    *   **功能点 8.2:** `handleClientDisconnect` - 处理客户端意外断开
        *   **依赖:** `Client.CurrentRole`, `Client.UserID`, `Client.SessionID`, `h.cardProviders`, `h.providerListSubscribers`, `h.sessions`, `h.terminateSessionByID`, `h.notifyProviderListSubscribers`。
        *   **测试点 (单元测试/集成测试关注点, mock 依赖):**
            *   **类型:** 单元测试 (mock Hub内部状态和方法)。
            *   **场景 8.2.1:** 断开的客户端是 `provider` 角色。
                *   **Arrange:** `client.CurrentRole = "provider"`, `client.UserID = "uid1"`。`client` 在 `h.cardProviders` 中。
                *   **Act:** `handleClientDisconnect(client)`。
                *   **Assert:**
                    *   `client` 从 `h.cardProviders` 移除。
                    *   `go h.notifyProviderListSubscribers("uid1")` 被调用 (异步)。
                    *   记录 "发卡方客户端断开连接..." Info 日志。
            *   **场景 8.2.2:** 断开的客户端在活动会话中。
                *   **Arrange:** `client.SessionID = "sid1"`。`h.sessions["sid1"]` 存在。Mock `activeSession.GetPeer()` 返回 mock `peerClient`。
                *   **Act:** `handleClientDisconnect(client)`。
                *   **Assert:** `h.terminateSessionByID("sid1", "客户端断开连接", client.GetID(), client.GetUserID())` 被调用。
            *   **场景 8.2.3:** 断开的客户端在会话中，其对端是 `provider`。会话终止后，该 `provider` 变空闲。
                *   **Arrange:** 同上，且 `peerClient` 是 `provider`。
                *   **Act:** `handleClientDisconnect(client)` -> `terminateSessionByID`。
                *   **Assert:** `go h.notifyProviderListSubscribers(peerClient.UserID)` 被调用 (在 `terminateSessionByID` 内部触发，或者如此处代码中的 `sessionToEndNotifyUserID` 逻辑)。
            *   **场景 8.2.4:** 断开的客户端不在任何会话中 (`client.SessionID` 为空)。
                *   **Assert:** `h.terminateSessionByID` 不被调用。
            *   **场景 8.2.5:** 断开的客户端是某些 `UserID` 的 `providerListSubscribers`。
                *   **Arrange:** `client` 在 `h.providerListSubscribers` 的某些条目中。
                *   **Assert:** `client` 从所有其订阅的 `h.providerListSubscribers[userID]` 映射中移除。如果某个 `userID` 的订阅者列表变空，则该 `userID` 条目从 `h.providerListSubscribers` 移除。记录 Debug 日志。

    *   **功能点 8.3:** `terminateSessionByID` - 核心会话终止逻辑
        *   **依赖:** `h.sessions`, `activeSession.Terminate()`, `ActiveSessions` metric, `LogAuditEvent`, `SessionTerminations` metric, `sendProtoMessage`, `h.notifyProviderListSubscribers`。
        *   **测试点 (单元测试, mock 依赖和 Hub 内部状态):**
            *   **类型:** 单元测试。
            *   **场景 8.3.1:** 尝试终止不存在的会话。
                *   **Arrange:** `sessionID` 不在 `h.sessions` 中。
                *   **Assert:** 函数提前返回。记录警告日志 "Attempted to terminate a non-existent session"。
            *   **场景 8.3.2:** 成功终止一个存在的会话 (通用断言部分)。
                *   **Arrange:** `sessionID` 存在于 `h.sessions`，关联一个 mock `activeSession` (包含 mock `CardEndClient` 和 `POSEndClient`)。Mock `LogAuditEvent`, `ActiveSessions.Dec()`, `SessionTerminations.WithLabelValues().Inc()`, `sendProtoMessage`, `h.notifyProviderListSubscribers`。
                *   **Act:** `terminateSessionByID(sessionID, reason, actingClientID, actingClientUserID)`。
                *   **Assert (通用部分):**
                    *   会话从 `h.sessions` 中删除。
                    *   `activeSession.Terminate()` 被调用。
                    *   `ActiveSessions.Dec()` 被调用。
                    *   记录 "会话已终止" Info 日志。
                    *   `CardEndClient.SessionID` 和 `POSEndClient.SessionID` 被清空 (如果它们是 `*Client` 类型)。
                    *   `sendProtoMessage` 被为 `CardEndClient` 和 `POSEndClient` 调用，发送包含正确 `reason` 的 `SessionTerminatedMessage`。
            *   **场景 8.3.3 - 8.3.7:** 测试不同的终止 `reason` 和 `actingClientID` 组合，验证 `eventType` (for audit log) 和 `metricReason` (for Prometheus) 的正确性。
                *   **Reason/ActingClient -> eventType / metricReason mapping:**
                    *   "客户端主动请求结束", actingClientID != "system" -> "session_terminated_by_client_request" / "client_request"
                    *   "客户端断开连接", actingClientID != "system" -> "session_terminated_by_client_disconnect" / "client_disconnect"
                    *   Other reason, actingClientID != "system" -> "session_terminated_by_client_action" / "client_generic_action"
                    *   "会话因长时间无活动已超时" -> "session_terminated_by_timeout" / "timeout"
                    *   "APDU转发失败导致会话终止" -> "session_terminated_by_apdu_error" / "apdu_error"
                    *   Other reason, actingClientID == "system" -> "session_terminated_by_system" / "system_generic"
                *   **Assert:** `LogAuditEvent` 被以正确的 `eventType` 和 `SessionDetails` (包含参与者信息和 `acting_client_id` 等) 调用。`SessionTerminations.WithLabelValues(metricReason).Inc()` 被调用。
            *   **场景 8.3.8:** 会话终止后，其中一个参与者是 `provider` 并变为空闲。
                *   **Arrange:** `activeSession.CardEndClient` (或 `POSEndClient`) 是 `provider`。
                *   **Assert:** `go h.notifyProviderListSubscribers(providerBecameFreeUserID)` 被调用。
            *   **场景 8.3.9:** 并发终止多个会话。
                *   **Assert:** `h.providerMutex.Lock()` 保护了对 `h.sessions`, `client.SessionID` (间接), `h.providerListSubscribers` 的并发访问。

    *   **功能点 8.4:** `checkInactiveSessions` - 周期性检查不活动会话
        *   **依赖:** `global.GVA_CONFIG.NfcRelay.SessionInactiveTimeoutSec`, `h.sessions`, `activeSession.IsInactive()`, `h.terminateSessionByID`。
        *   **测试点 (集成测试关注点/单元测试模拟 ticker):**
            *   **类型:** 单元测试 (模拟时间流逝和 Hub 状态)。
            *   **场景 8.4.1:** `SessionInactiveTimeoutSec` 配置为0或非法值。
                *   **Arrange:** `global.GVA_CONFIG.NfcRelay.SessionInactiveTimeoutSec = 0`。
                *   **Assert:** 函数提前返回。记录警告日志 "SessionInactiveTimeoutSec config is invalid..."。
            *   **场景 8.4.2:** 没有活动会话。
                *   **Assert:** 循环不执行，无操作。
            *   **场景 8.4.3:** 存在多个会话，部分不活动 (已配对且超时)，部分活动，部分未配对。
                *   **Arrange:**
                    *   `session1`: paired, `IsInactive()` 返回 `true`。
                    *   `session2`: paired, `IsInactive()` 返回 `false`。
                    *   `session3`: waiting_for_pairing, `IsInactive()` 返回 `false` (或不应被检查)。
                    *   Mock `h.terminateSessionByID`。
                *   **Assert:** `h.terminateSessionByID` 仅为 `session1` 调用，原因为 "会话因长时间无活动已超时", `actingClientID="system"`, `actingClientUserID=""`。记录 Info 日志 "Terminating inactive session"。
            *   **场景 8.4.4:** 所有会话都活动。
                *   **Assert:** `h.terminateSessionByID` 不被调用。

---

**模块 9: 会话对象 (`backend/nfc_relay/session/session.go`)**

*   **核心功能:** 定义会话的结构、状态和基本操作。

    *   **功能点 9.1:** `ClientInfoProvider` 接口定义
        *   **测试点 (代码审查):** 验证接口方法是否满足 `Session` 与 `Client` 解耦的需求。

    *   **功能点 9.2:** `SessionStatus` 常量定义
        *   **测试点 (代码审查):** 验证常量值的正确性。

    *   **功能点 9.3:** `Session` 结构体定义
        *   **子功能点 9.3.1:** `SessionID string`
        *   **子功能点 9.3.2:** `CardEndClient ClientInfoProvider`
        *   **子功能点 9.3.3:** `POSEndClient ClientInfoProvider`
        *   **子功能点 9.3.4:** `Status SessionStatus`
        *   **子功能点 9.3.5:** `LastActivityTime time.Time`
        *   **子功能点 9.3.6:** `mu sync.RWMutex`
        *   **测试点 (代码审查):** 字段类型和用途。

    *   **功能点 9.4:** `NewSession(sessionID string)` 构造函数
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 9.4.1:** 成功创建新会话。
                *   **Assert:** `SessionID` 被设置，`Status` 为 `StatusWaitingForPairing`，`LastActivityTime` 被初始化为 `time.Now()` (允许有细微误差)。`CardEndClient` 和 `POSEndClient` 为 `nil`。

    *   **功能点 9.5:** `Session.UpdateActivityTime()`
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 9.5.1:** 成功更新 `LastActivityTime`。
                *   **Arrange:** 创建 Session，等待一小段时间。
                *   **Act:** `s.UpdateActivityTime()`。
                *   **Assert:** `s.LastActivityTime` 更新为接近当前的 `time.Now()`。

    *   **功能点 9.6:** `Session.IsInactive(timeout time.Duration)`
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 9.6.1:** 会话状态为 `StatusPaired`，未超时。
                *   **Arrange:** `s.Status = StatusPaired`, `s.LastActivityTime = time.Now()`. `timeout = 1 * time.Minute`.
                *   **Assert:** 返回 `false`。
            *   **场景 9.6.2:** 会话状态为 `StatusPaired`，已超时。
                *   **Arrange:** `s.Status = StatusPaired`, `s.LastActivityTime = time.Now().Add(-2 * time.Minute)`. `timeout = 1 * time.Minute`.
                *   **Assert:** 返回 `true`。
            *   **场景 9.6.3:** 会话状态非 `StatusPaired` (e.g., `StatusWaitingForPairing` 或 `StatusTerminated`)，即使时间超过 `timeout`。
                *   **Arrange:** `s.Status = StatusWaitingForPairing`, `s.LastActivityTime = time.Now().Add(-2 * time.Minute)`.
                *   **Assert:** 返回 `false`。

    *   **功能点 9.7:** `Session.Terminate()`
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 9.7.1:** 成功将会话状态标记为终止。
                *   **Arrange:** 创建 Session (任意初始状态)。
                *   **Act:** `s.Terminate()`。
                *   **Assert:** `s.Status` 变为 `StatusTerminated`。

    *   **功能点 9.8:** `Session.SetClient(client ClientInfoProvider, role string)`
        *   **测试点 (单元测试, mock `ClientInfoProvider`):**
            *   **类型:** 单元测试。
            *   **场景 9.8.1:** 会话已终止，尝试设置客户端。
                *   **Arrange:** `s.Status = StatusTerminated`。
                *   **Assert:** 返回 `false, &SessionError{"会话已终止，无法加入"}`。
            *   **场景 9.8.2:** 成功设置第一个客户端 (`CardEndClient`, role="card")。
                *   **Arrange:** `s.Status = StatusWaitingForPairing`。Mock `client1`。
                *   **Assert:** `s.CardEndClient` 为 `client1`。返回 `false, nil` (未配对)。`s.Status` 仍为 `StatusWaitingForPairing`。
            *   **场景 9.8.3:** 成功设置第二个客户端 (`POSEndClient`, role="pos")，会话配对成功。
                *   **Arrange:** `s.CardEndClient` 已设置。`s.Status = StatusWaitingForPairing`。Mock `client2`。
                *   **Act:** `s.SetClient(client2, "pos")`。
                *   **Assert:** `s.POSEndClient` 为 `client2`。返回 `true, nil` (配对成功)。`s.Status` 变为 `StatusPaired`。`s.LastActivityTime` 被更新。
            *   **场景 9.8.4:** 角色已被占用。
                *   **Arrange:** `s.CardEndClient` 已被 `client1` 占用。尝试用 `client2` 再次设置 "card" 角色。
                *   **Assert:** 返回 `false, &SessionError{"传卡端角色已被占用"}`。`s.CardEndClient` 仍为 `client1`。
            *   **场景 9.8.5:** 无效的角色字符串。
                *   **Arrange:** `role = "invalid_role"`。
                *   **Assert:** 返回 `false, &SessionError{"无效的客户端角色: invalid_role"}`。
            *   **场景 9.8.6:** 尝试将同一个客户端实例设置到不同角色 (理论上不应发生，但代码应能处理)。
                *   **Arrange:** 先将 `client1` 设置为 "card"。再尝试将 `client1` 设置为 "pos"。
                *   **Assert:** 行为取决于具体逻辑，当前实现会覆盖。如果这是不允许的，需要额外检查。

    *   **功能点 9.9:** `Session.RemoveClient(client ClientInfoProvider)`
        *   **测试点 (单元测试, mock `ClientInfoProvider`):**
            *   **类型:** 单元测试。
            *   **场景 9.9.1:** 会话已终止，尝试移除客户端。
                *   **Arrange:** `s.Status = StatusTerminated`。
                *   **Assert:** 无操作，提前返回。
            *   **场景 9.9.2:** 从已配对会话中移除 `CardEndClient`。
                *   **Arrange:** `s.Status = StatusPaired`, `s.CardEndClient = client1`, `s.POSEndClient = client2`。
                *   **Act:** `s.RemoveClient(client1)`。
                *   **Assert:** `s.CardEndClient` 变为 `nil`。`s.Status` 变为 `StatusWaitingForPairing`。
            *   **场景 9.9.3:** 从等待配对的会话中移除一个已加入的客户端。
                *   **Arrange:** `s.Status = StatusWaitingForPairing`, `s.CardEndClient = client1`, `s.POSEndClient = nil`。
                *   **Act:** `s.RemoveClient(client1)`。
                *   **Assert:** `s.CardEndClient` 变为 `nil`。`s.Status` 仍为 `StatusWaitingForPairing`。
            *   **场景 9.9.4:** 尝试移除不在会话中的客户端。
                *   **Arrange:** `client3` 不在 `s.CardEndClient` 或 `s.POSEndClient`。
                *   **Assert:** 无操作，状态不变。

    *   **功能点 9.10:** `Session.GetPeer(client ClientInfoProvider)`
        *   **测试点 (单元测试, mock `ClientInfoProvider`):**
            *   **类型:** 单元测试。
            *   **场景 9.10.1:** 会话未配对 (`Status != StatusPaired`)。
                *   **Arrange:** `s.Status = StatusWaitingForPairing`。
                *   **Assert:** 返回 `nil`。
            *   **场景 9.10.2:** 成功获取 `CardEndClient` 的对端 (`POSEndClient`)。
                *   **Arrange:** `s.Status = StatusPaired`, `s.CardEndClient = client1`, `s.POSEndClient = client2`。
                *   **Assert:** `s.GetPeer(client1)` 返回 `client2`。
            *   **场景 9.10.3:** 成功获取 `POSEndClient` 的对端 (`CardEndClient`)。
                *   **Assert:** `s.GetPeer(client2)` 返回 `client1`。
            *   **场景 9.10.4:** 传入的客户端不在当前会话中。
                *   **Arrange:** `s.Status = StatusPaired`。`client3` 未加入会话。
                *   **Assert:** `s.GetPeer(client3)` 返回 `nil`。

    *   **功能点 9.11:** `SessionError` 错误类型
        *   **测试点 (单元测试):**
            *   **类型:** 单元测试。
            *   **场景 9.11.1:** `Error()` 方法返回正确的错误消息。
                *   **Arrange:** `err := &SessionError{Message: "test error"}`。
                *   **Assert:** `err.Error()` 返回 `"test error"`。

    *   **功能点 9.12:** 并发安全
        *   **测试点 (单元测试, 使用 `t.Parallel()`):**
            *   **类型:** 单元测试 (针对单个Session对象)。
            *   **场景 9.12.1:** 并发调用 `SetClient`, `RemoveClient`, `UpdateActivityTime`, `IsInactive`, `GetPeer`, `Terminate`。
                *   **Arrange:** 创建一个 Session 实例。
                *   **Act:** 在多个 goroutine 中并发调用其方法。
                *   **Assert:** `s.mu` (RWMutex) 正确保护了对 Session 内部状态的并发访问。无数据竞争 (通过 `-race` 检测)。最终状态符合预期 (可能需要仔细设计并发场景以验证特定状态转换)。

---

**模块 10: 审计日志 (`backend/global/audit.go` 与 Hub 中的调用)**

*   **核心功能:** 提供结构化的审计日志记录机制，用于追踪关键系统事件。

    *   **功能点 10.1:** `AuditEvent` 结构体定义
        *   **子功能点 10.1.1 - 10.1.7:** 包含 `Timestamp`, `EventType`, `SessionID`, `ClientIDInitiator`, `ClientIDResponder`, `SourceIP`, `UserID`, `Details interface{}` 字段及其 `json` 标签。
        *   **测试点 (代码审查/静态分析):** 验证字段名、类型、`json` 标签的正确性。

    *   **功能点 10.2:** `AuditLogger *zap.Logger` 变量
        *   **测试点 (代码审查):** 全局变量定义。

    *   **功能点 10.3:** `InitializeAuditLogger()` 函数
        *   **依赖:** `global.GVA_LOG` (zap.Logger)。
        *   **测试点 (单元测试, mock `global.GVA_LOG`):**
            *   **类型:** 单元测试。
            *   **场景 10.3.1:** `global.GVA_LOG` 已初始化。
                *   **Arrange:** Mock `global.GVA_LOG` 为一个有效的 `*zap.Logger`。
                *   **Act:** `InitializeAuditLogger()`。
                *   **Assert:** `global.AuditLogger` 被初始化为 `GVA_LOG.Named("audit")`，且不为 `nil`。
            *   **场景 10.3.2:** `global.GVA_LOG` 未初始化 (`nil`)。
                *   **Arrange:** `global.GVA_LOG = nil`。 (需要能 mock `zap.NewProduction()` 或捕获其panic)。
                *   **Act:** `InitializeAuditLogger()`。
                *   **Assert:**
                    *   `AuditLogger` 被初始化为一个新的 `zap.Logger` (fallback logger, named "audit")。
                    *   原始的 `GVA_LOG` (如果能mock并观察) 记录 "AuditLogger initialized with fallback..." 警告 (这要求GVA_LOG之后被赋值才能记录)。
                    *   如果 `zap.NewProduction()` 失败，则发生 panic (测试时需捕获)。

    *   **功能点 10.4:** `LogAuditEvent(eventType string, details interface{}, fields ...zap.Field)` 函数
        *   **依赖:** `AuditLogger`, `InitializeAuditLogger()`, `time.Now()`, `json.Marshal()`, `json.Unmarshal()`.
        *   **测试点 (单元测试, mock `AuditLogger` 和其他依赖):**
            *   **类型:** 单元测试 (需要 mock `zap.Logger` 的 `Info` 方法或使用 `zaptest/observer` 来捕获日志条目)。
            *   **场景 10.4.1:** `AuditLogger` 未初始化，首次调用时成功初始化。
                *   **Arrange:** `AuditLogger = nil`。Mock `InitializeAuditLogger` (或让其执行)。Mock `GVA_LOG.Info` (用于记录 "AuditLogger was nil...")。
                *   **Act:** `LogAuditEvent(...)`。
                *   **Assert:** `InitializeAuditLogger` 被调用。`GVA_LOG.Info("AuditLogger was nil...")` 被记录。后续日志记录成功。
            *   **场景 10.4.2:** `AuditLogger` 初始化失败 (即使在 `LogAuditEvent` 内部尝试后仍然为 `nil`)。
                *   **Arrange:** `AuditLogger = nil`。Mock `InitializeAuditLogger` 使其执行后 `AuditLogger` 仍为 `nil`。Mock `GVA_LOG.Error`。
                *   **Assert:** `GVA_LOG.Error("AuditLogger is not initialized...")` 被记录。函数提前返回。
            *   **场景 10.4.3:** 成功记录包含 `eventType` 和 `details` 的审计事件。
                *   **Arrange:** `AuditLogger` 已初始化。`details` 为可序列化结构体 (如 `AuthDetails`)。
                *   **Act:** `LogAuditEvent("test_event", AuthDetails{Username: "user1"}, zap.String("extra", "value"))`。
                *   **Assert (通过捕获的日志条目):**
                    *   日志级别为 Info，消息为 "AuditEvent"。
                    *   包含字段 `timestamp` (RFC3339Nano格式)。
                    *   包含字段 `event_type` ("test_event")。
                    *   包含字段 `details` (其内容为 `AuthDetails` 序列化后的 map)。
                    *   包含传入的额外 `zap.Field` (`extra: "value"`).
                    *   所有 `AuditEvent` 结构体中的字段 (如 `session_id` 等，如果通过 `details` 的 map 形式或 `zap.Field` 传入) 都应在日志中。
            *   **场景 10.4.4:** `json.Marshal(event)` 失败。
                *   **Arrange:** 构造一个无法被 `json.Marshal` 的 `AuditEvent` (例如，让 `Details` 包含一个 channel)。Mock `GVA_LOG.Error`。
                *   **Assert:**
                    *   `GVA_LOG.Error("Failed to marshal AuditEvent...")` 被记录。
                    *   日志回退到只记录原始的 `eventType` 和 `details` (作为 `zap.Any("details", details)`)。
            *   **场景 10.4.5:** `Details` 为 `nil`。
                *   **Assert:** 日志中 `details` 字段不存在或为 `null`。
            *   **场景 10.4.6:** 不传入额外的 `zap.Field`。
                *   **Assert:** 日志中仅包含 `AuditEvent` 本身的字段。

    *   **功能点 10.5:** `AuthDetails`, `SessionDetails`, `APDUDetails`, `ErrorDetails` 结构体定义
        *   **测试点 (代码审查/单元测试序列化):**
            *   **类型:** 单元测试 (验证JSON序列化)。
            *   **场景 10.5.1:** 各 `Details` 结构体能被正确序列化和反序列化为JSON。
                *   **Arrange:** 创建各 `Details` 结构体的实例并填充字段。
                *   **Act:** `json.Marshal()` 和 `json.Unmarshal()`。
                *   **Assert:** 序列化和反序列化过程无误，结果符合预期，`json` 标签 (`omitempty` 等) 生效。

    *   **功能点 10.6:** Hub 中对 `LogAuditEvent` 的调用 (集成测试关注点)
        *   **测试点 (集成测试, 通过模拟Hub操作触发, mock `AuditLogger` 或检查日志输出):**
            *   **类型:** 集成测试。
            *   **场景 10.6.1 - N:** 验证在 `hub.go` 中所有标记为 "// Audit Log for..." 的地方，`LogAuditEvent` 都被以正确的 `eventType`, `details` (及填充的 `Details` 结构体), 和上下文相关的 `zap.Field` (如 `session_id`, `client_id`, `user_id`, `source_ip`) 调用。
                *   **覆盖的事件类型 (至少):**
                    *   `error_occurred` (handleIncomingMessage: bad request, auth required, unsupported type; sendErrorMessage)
                    *   `auth_success`, `auth_failure` (handleClientAuth - 注意：当前这些直接由 Prometheus 指标处理，但原设计有，可确认是否仍需独立审计)
                    *   `session_established` (handleSelectCardProvider)
                    *   `apdu_relayed_attempt`, `apdu_relayed_success`, `apdu_relayed_failure` (handleAPDUExchange)
                    *   `session_terminated_by_client_request`, `session_terminated_by_client_disconnect`, `session_terminated_by_timeout`, `session_terminated_by_apdu_error`, `session_terminated_by_system` (terminateSessionByID)
                    *   `client_error_notification_sent` (sendErrorMessage)
                *   **Assert:** 检查捕获的日志条目，验证其 `eventType`, `details` 内容，以及所有相关的 `zap.Field` 是否与操作上下文一致。

---

**模块 11: Prometheus 指标 (`backend/nfc_relay/handler/metrics.go` 与 Hub 中的更新及 `/metrics` 端点)**

*   **核心功能:** 提供系统关键操作的性能和状态指标，并可通过 HTTP 端点暴露给 Prometheus。

    *   **功能点 11.1:** 指标定义 (`metrics.go`)
        *   **子功能点 11.1.1 - 11.1.7:** `ActiveConnections` (Gauge), `ActiveSessions` (Gauge), `ApduMessagesRelayed` (CounterVec), `ApduRelayErrors` (CounterVec), `SessionTerminations` (CounterVec), `HubErrors` (CounterVec), `AuthEvents` (CounterVec) 的 `prometheus.GaugeOpts` 和 `prometheus.CounterOpts` (Name, Help, Labels) 定义正确。
        *   **测试点 (代码审查/静态分析):** 验证指标名称、帮助信息、标签名是否清晰、一致且符合 Prometheus 命名约定。

    *   **功能点 11.2:** Hub 中对指标的更新 (集成测试关注点)
        *   **依赖:** 各 Prometheus 指标对象 (`.Inc()`, `.Dec()`, `.WithLabelValues().Inc()`)。
        *   **测试点 (集成测试, 通过模拟Hub操作触发, mock 指标对象或检查 `/metrics` 端点):**
            *   **类型:** 集成测试 (需要能够读取或 mock 指标状态)。
            *   **场景 11.2.1:** `ActiveConnections` 更新。
                *   **Act:** 客户端注册 (`h.register`) / 注销 (`h.unregister`)。
                *   **Assert:** `ActiveConnections` 指标相应地增加/减少。
            *   **场景 11.2.2:** `ActiveSessions` 更新。
                *   **Act:** 会话建立 (`handleSelectCardProvider`) / 终止 (`terminateSessionByID`)。
                *   **Assert:** `ActiveSessions` 指标相应地增加/减少。
            *   **场景 11.2.3:** `ApduMessagesRelayed` 和 `ApduRelayErrors` 更新。
                *   **Act:** APDU 成功转发 / 转发失败 (`handleAPDUExchange`)。
                *   **Assert:** 对应的 `CounterVec` 根据 `direction` 和 `session_id` 标签增加。
            *   **场景 11.2.4:** `SessionTerminations` 更新。
                *   **Act:** 不同原因的会话终止 (`terminateSessionByID`)。
                *   **Assert:** 对应的 `CounterVec` 根据 `reason` 标签 (`metricReason` 变量的值) 增加。
            *   **场景 11.2.5:** `HubErrors` 更新。
                *   **Act:** Hub 内部错误导致调用 `sendErrorMessage`。
                *   **Assert:** 对应的 `CounterVec` 根据 `error_code` 和 `component` 标签增加。
            *   **场景 11.2.6:** `AuthEvents` 更新。
                *   **Act:** 客户端认证成功/失败 (`handleClientAuth`)。
                *   **Assert:** 对应的 `CounterVec` 根据 `type` ("success"/"failure") 和 `reason` 标签增加。

    *   **功能点 11.3:** `/metrics` HTTP 端点暴露 (`backend/initialize/router.go`)
        *   **依赖:** `gin.WrapH(promhttp.Handler())`.
        *   **测试点 (HTTP 端点测试):**
            *   **类型:** HTTP 测试 (需要启动 Gin 服务器)。
            *   **场景 11.3.1:** 成功访问 `/metrics` 端点。
                *   **Arrange:** 启动应用。
                *   **Act:** 发送 GET 请求到 `/metrics`。
                *   **Assert:** 收到 HTTP 200 OK 响应。响应内容为 Prometheus 格式的文本，包含所有在 `metrics.go` 中定义的 NFC 中继相关指标及其当前值。
            *   **场景 11.3.2:** 在执行一些操作后，指标值更新。
                *   **Arrange:** 启动应用，执行一些会影响指标的操作 (如客户端连接、建立会话、APDU交换)。
                *   **Act:** 再次访问 `/metrics`。
                *   **Assert:** 响应中的指标值反映了这些操作。

---

**模块 12: 系统初始化与路由 (`backend/main.go`, `backend/initialize/router.go`, `backend/nfc_relay/router/router.go`)**

*   **核心功能:** 正确初始化系统组件 (包括NFC Relay Hub)，并设置 WebSocket 路由。

    *   **功能点 12.1:** `main.initializeSystem()` 中 Hub 的启动
        *   **依赖:** `handler.GlobalRelayHub.Run()`.
        *   **测试点 (集成测试关注点):**
            *   **类型:** 集成测试 (关注系统启动流程)。
            *   **场景 12.1.1:** Hub 成功启动。
                *   **Arrange:** 启动应用。
                *   **Act:** `initializeSystem()` 执行。
                *   **Assert:** `handler.GlobalRelayHub.Run()` 在一个新的 goroutine 中被调用。记录 "NFC Relay Hub started" Info 日志。 (可以通过检查 Hub 是否能接受客户端连接来间接验证)。

    *   **功能点 12.2:** `initialize.Routers()` 中 Prometheus `/metrics` 端点的注册
        *   **测试点 (代码审查/集成测试):**
            *   **类型:** 代码审查。
            *   **场景 12.2.1:** `/metrics` 路由正确注册。
                *   **Assert:** `Router.GET("/metrics", gin.WrapH(promhttp.Handler()))` 代码存在且正确。 (已在模块 11.3 测试)

    *   **功能点 12.3:** `NFCRelayRouter.InitNFCRelayRouter(PublicGroup)` 路由初始化 (`backend/nfc_relay/router/router.go`)
        *   **依赖:** `gin.RouterGroup`, `handler.ServeWs` (WebSocket处理器)。
        *   **测试点 (单元测试 `InitNFCRelayRouter` / HTTP 端点测试):**
            *   **类型:** 单元测试 (测试路由注册逻辑)。
            *   **场景 12.3.1:** WebSocket 路由 `/nfc_relay/ws` 正确注册到 `PublicGroup`。
                *   **Arrange:** 创建一个 mock `gin.RouterGroup`。
                *   **Act:** 调用 `InitNFCRelayRouter(mockGroup)`。
                *   **Assert:** `mockGroup.GET("/ws", handler.ServeWs)` 被调用。
            *   **HTTP 端点测试 (WebSocket 升级):**
                *   **类型:** HTTP 测试 (尝试 WebSocket 连接)。
                *   **场景 12.3.2:** 客户端尝试与 `/nfc_relay/ws` 建立 WebSocket 连接。
                    *   **Arrange:** 启动应用。
                    *   **Act:** 使用 WebSocket 客户端尝试连接到 `ws://<host>:<port>/nfc_relay/ws` (或 `/api/nfc_relay/ws` 如果有 `RouterPrefix`)。
                    *   **Assert:** WebSocket 握手成功 (HTTP 101 Switching Protocols)。`handler.ServeWs` 被调用，进而创建 `Client` 实例并注册到 Hub。

    *   **功能点 12.4:** `handler.ServeWs(c *gin.Context)` WebSocket 连接处理器
        *   **依赖:** `websocket.Upgrader`, `NewClient()`, `client.hub.register`, `client.readPump()`, `client.writePump()`.
        *   **测试点 (HTTP 端点测试/集成测试):**
            *   **类型:** 集成测试 (测试从 HTTP 请求到 WebSocket Client 创建和运行的完整流程)。
            *   **场景 12.4.1:** 成功升级 HTTP 连接到 WebSocket。
                *   **Arrange:** HTTP GET 请求到 `/ws` 端点，包含正确的 WebSocket 升级头部。
                *   **Act:** `ServeWs` 处理请求。
                *   **Assert:**
                    *   `upgrader.Upgrade(c.Writer, c.Request, nil)` 成功。
                    *   `NewClient(GlobalRelayHub, conn)` 被调用创建新客户端。
                    *   `client.hub.register <- client` 被执行 (客户端被发送到 Hub 的注册通道)。
                    *   `go client.writePump()` 和 `go client.readPump()` 被启动。
            *   **场景 12.4.2:** WebSocket 升级失败 (如请求非 GET，或缺少升级头部)。
                *   **Arrange:** 发送不符合 WebSocket 升级要求的 HTTP 请求。
                *   **Act:** `ServeWs` 处理。
                *   **Assert:** `upgrader.Upgrade()` 返回错误。不创建客户端，不启动读写 goroutine。HTTP 响应为错误状态码 (如 400 Bad Request)。记录 "Failed to upgrade to websocket:" Error 日志。
            *   **场景 12.4.3:** `CheckOrigin` 策略 (当前 `websocket.Upgrader` 使用默认，允许所有源)。
                *   **测试点 (代码审查/可选测试):** 如果未来添加了 `CheckOrigin` 函数，需要测试其允许和拒绝逻辑。

