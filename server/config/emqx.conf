actions {
  http {
    WebHook {
      connector = connector_WebHook
      enable = true
      parameters {
        body = "    {\r\n      \"event\": \"${event}\",\r\n      \"clientid\": \"${clientid}\",\r\n      \"username\": \"${username}\",\r\n      \"peerhost\": \"${peerhost}\",\r\n      \"peerport\": ${peerport},\r\n      \"sockport\": ${sockport},\r\n      \"protocol\": \"${protocol}\",\r\n      \"proto_ver\": ${proto_ver},\r\n      \"keepalive\": ${keepalive},\r\n      \"clean_start\": ${clean_start},\r\n      \"timestamp\": \"${timestamp}\",\r\n      \"connected_at\": ${connected_at}\r\n    }"
        headers {}
        max_retries = 2
        method = post
        path = ""
      }
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 1GB
        query_mode = async
        request_ttl = 45s
        start_after_created = true
        start_timeout = 5s
        worker_pool_size = 4
      }
    }
    backend_role_api {
      connector = connector_backend_role_api
      description = ""
      enable = true
      parameters {
        body = "{\r\n    \"event\": \"${event}\",\r\n    \"clientid\": \"${clientid}\",\r\n    \"username\": \"${username}\",\r\n    \"connected_at\": \"${connected_at}\",\r\n    \"disconnected_at\": \"${disconnected_at}\",\r\n    \"reason\": \"${reason}\",\r\n    \"timestamp\": \"${timestamp}\"\r\n  }"
        headers {}
        max_retries = 2
        method = post
        path = ""
      }
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 1GB
        query_mode = async
        request_ttl = 45s
        start_after_created = true
        start_timeout = 5s
        worker_pool_size = 4
      }
    }
    webhook_for_disconnect {
      connector = connector_webhook_for_disconnect
      parameters {
        body = "        {\r\n          \"event\": \"${event}\",\r\n          \"clientid\": \"${clientid}\",\r\n          \"username\": \"${username}\",\r\n          \"reason\": \"${reason}\",\r\n          \"timestamp\": \"${timestamp}\",\r\n          \"disconnected_at\": ${disconnected_at}\r\n        }"
        headers {}
        method = post
        path = ""
      }
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 1GB
        query_mode = async
        request_ttl = 45s
        start_timeout = 5s
        worker_pool_size = 4
      }
    }
  }
}
authentication = [
  {
    backend = http
    body {
      action = "${action}"
      clientid = "${clientid}"
      peerhost = "${peerhost}"
      topic = "${topic}"
      username = "${username}"
      password = "${password}"
    }
    connect_timeout = 15s
    enable = true
    enable_pipelining = 100
    headers {
      accept = "application/json"
      cache-control = no-cache
      connection = keep-alive
      content-type = "application/json"
      keep-alive = "timeout=30, max=1000"
    }
    mechanism = password_based
    method = post
    pool_size = 8
    request_timeout = 5s
    ssl {
      ciphers = []
      depth = 10
      enable = false
      hibernate_after = 5s
      log_level = notice
      reuse_sessions = true
      secure_renegotiate = true
      verify = verify_peer
      versions = [tlsv1.3, tlsv1.2]
    }
    url = "http://192.168.50.194:8888/mqtt/auth"
  }
]
authorization {
  cache {
    enable = true
    max_size = 32
    ttl = 1m
  }
  deny_action = ignore
  no_match = deny
  sources = [
    {
      backend = http
      body {
        action = "${action}"
        clientid = "${clientid}"
        peerhost = "${peerhost}"
        topic = "${topic}"
        username = "${username}"
      }
      connect_timeout = 15s
      enable = true
      enable_pipelining = 100
      headers {
        accept = "application/json"
        cache-control = no-cache
        connection = keep-alive
        content-type = "application/json"
        keep-alive = "timeout=30, max=1000"
      }
      method = post
      pool_size = 8
      request_timeout = 30s
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_peer
        versions = [tlsv1.3, tlsv1.2]
      }
      type = http
      url = "http://192.168.50.194:8888/mqtt/acl"
    },
    {
      enable = false
      path = "data/authz/acl.conf"
      type = file
    }
  ]
}
connectors {
  http {
    connector_WebHook {
      connect_timeout = 15s
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      pool_size = 8
      pool_type = hash
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_peer
        versions = [tlsv1.3, tlsv1.2]
      }
      url = "http://192.168.50.194:8888/mqtt/webhook"
    }
    connector_backend_role_api {
      connect_timeout = 15s
      description = ""
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      pool_size = 8
      pool_type = hash
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_peer
        versions = [tlsv1.3, tlsv1.2]
      }
      url = "http://192.168.50.194:8888/mqtt/hooks/connection_status"
    }
    connector_webhook_for_disconnect {
      connect_timeout = 15s
      enable_pipelining = 100
      headers {content-type = "application/json"}
      pool_size = 8
      pool_type = hash
      ssl {enable = false, verify = verify_peer}
      url = "http://192.168.50.194:8888/mqtt/webhook"
    }
  }
}
log {
  console {
    enable = true
    formatter = text
    level = all
    time_offset = system
  }
  file {
    default {
      enable = true
      formatter = text
      level = all
      path = "e:/Tools/emqx/log/emqx.log"
      rotation_count = 10
      rotation_size = 50MB
      time_offset = system
    }
  }
}
rule_engine {
  ignore_sys_message = true
  jq_function_default_timeout = 10s
  rules {
    role_request_handler {
      actions = ["webhook:WebHook"]
      description = ""
      enable = false
      metadata {created_at = 1750703054818}
      name = ""
      sql = "SELECT\n  clientid,\n  payload.role as role,\n  payload.force_kick as force_kick,\n  payload.device_id as device_id,\n  payload.user_id as user_id,\n  timestamp\nFROM\n  \"client/+/control/set_role_request\"\nWHERE\n  payload.role != ''"
    }
    rule_ziqh {
      actions = ["webhook:WebHook"]
      description = ""
      enable = false
      metadata {created_at = 1750702997164}
      name = ""
      sql = "SELECT\n  clientid,\n  username,\n  event,\n  connected_at,\n  disconnected_at,\n  reason,\n  timestamp\nFROM\n  \"$events/client_connected\", \"$events/client_disconnected\""
    }
    webhook_client_connected {
      actions = ["webhook:WebHook"]
      description = ""
      enable = true
      metadata {created_at = 1750784535346}
      name = ""
      sql = "SELECT\n  event,\n  clientid,\n  username,\n  CASE\n    WHEN peerhost IS NOT NULL THEN peerhost\n    ELSE 'unknown'\n  END as peerhost,\n  CASE\n    WHEN peerport IS NOT NULL THEN peerport\n    ELSE 0\n  END as peerport,\n  CASE\n    WHEN sockport IS NOT NULL THEN sockport\n    ELSE 0\n  END as sockport,\n  proto_name as protocol,\n  proto_ver,\n  keepalive,\n  clean_start,\n  timestamp,\n  connected_at\nFROM\n  \"$events/client_connected\"\nWHERE\n  username <> '' AND clientid <> ''"
    }
    webhook_client_disconnected {
      actions = ["webhook:webhook_for_disconnect"]
      description = ""
      enable = true
      metadata {created_at = 1750784582529}
      name = ""
      sql = "SELECT\n  event,\n  clientid,\n  username,\n  reason,\n  timestamp,\n  disconnected_at\nFROM\n  \"$events/client_disconnected\"\nWHERE\n  username <> '' AND clientid <> ''"
    }
  }
} 