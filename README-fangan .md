
**NFC 中继支付系统 - 服务器端开发计划 (基于 Go 和 Gin)**

**核心目标：** 构建一个安全、低延迟、高可用的服务器，作为传卡端 (Card-End) 和收卡端 (POS-End) Android 客户端之间的 APDU 消息中继。

**技术选型（与现有项目保持一致性）：**

*   **语言：** Go
*   **Web 框架：** Gin (`github.com/gin-gonic/gin`)
*   **WebSocket 库：** Gorilla WebSocket (`github.com/gorilla/websocket`) 或其他高性能 Go WebSocket 库。Gin 本身不直接处理 WebSocket，通常需要配合这类库。
*   **缓存/会话存储 (可选但推荐，用于扩展性)：** Redis (`github.com/redis/go-redis/v9`)
*   **日志：** Zap (`go.uber.org/zap`) (与项目现有日志库一致)
*   **配置：** Viper (`github.com/spf13/viper`) (与项目现有配置管理一致)

---

**阶段零：准备工作与环境搭建 (复用与增强现有环境)**

1.  **理解现有项目结构：**
    *   **负责人：** 开发团队
    *   **任务：** 深入理解 `gin-vue-admin` 的后端代码结构，特别是 `core/`, `global/`, `initialize/`, `router/`, `service/`, `middleware/` 目录。
    *   **最佳实践：**
        *   梳理现有项目的请求处理流程、中间件使用、数据库交互方式。
        *   明确新功能如何与现有认证、日志、配置系统集成。
2.  **WebSocket 库选型与集成：**
    *   **负责人：** 后端架构师/核心开发者
    *   **任务：** 调研并确定最适合的 Go WebSocket 库。Gorilla WebSocket 是一个成熟的选择。研究如何将其优雅地集成到 Gin 路由中。
    *   **最佳实践：**
        *   编写原型代码验证 WebSocket 连接、消息收发。
        *   考虑连接升级、错误处理、并发管理。
3.  **定义项目模块与目录结构：**
    *   **负责人：** 后端架构师/核心开发者
    *   **任务：** 为 NFC 中继功能规划新的包/模块。例如：
        *   `nfc_relay/`
            *   `handler/` (处理 WebSocket 连接和消息)
            *   `session/` (会话管理、配对逻辑)
            *   `protocol/` (定义客户端与服务器间的消息结构体)
            *   `service/` (NFC 中继核心服务逻辑)
    *   **最佳实践：**
        *   遵循现有项目的模块化风格。
        *   保持职责分离。
4.  **API/消息协议最终确定：**
    *   **负责人：** 前后端开发团队
    *   **任务：** 根据提供的《NFC中继支付系统技术开发手册》3.5节，最终确定服务器与客户端之间所有 WebSocket 消息的 JSON 结构和事件名称。
    *   **最佳实践：**
        *   创建共享的协议定义文件（例如 Go 结构体，可以转换为 JSON Schema 或其他格式供客户端参考）。
        *   版本化 API 协议以备将来扩展。

---

**阶段一：核心服务器功能实现 (基于 Go + WebSocket)**

1.  **客户端连接管理 (手册 3.2)：**
    *   **负责人：** 后端开发者
    *   **任务：**
        *   实现 WebSocket 端点 (例如 `/ws/relay`)，处理连接升级请求。
        *   管理活跃的 WebSocket 连接 (例如使用 `map[string]*websocket.Conn` 存储 `socket.id` 到连接的映射)。
        *   处理连接建立、断开 (`disconnect`)、错误 (`error`) 事件。
    *   **最佳实践：**
        *   为每个连接生成唯一的标识符 (如果库不提供)。
        *   在连接断开时，确保资源被正确清理（从活跃连接列表中移除，关闭相关协程）。
        *   使用 `sync.Map` 或带有互斥锁的 `map` 来安全地并发访问连接池。
        *   为每个客户端连接启动独立的 Goroutine 处理消息读取和写入，避免阻塞主处理循环。
2.  **会话管理与配对逻辑 (手册 3.3, 2.4)：**
    *   **负责人：** 后端开发者
    *   **任务：**
        *   设计会话数据结构 (例如 `map[string]*Session`，`sessionId` 为键)。Session 结构包含 `CardEndClientID`, `POSEndClientID`, `Status` 等。
        *   实现客户端注册逻辑 (`client_register` 消息处理)：
            *   验证 `role` 和 `sessionId` (或 `pairingCode`)。
            *   将客户端分配给会话，并更新会话状态。
            *   处理同一会话中角色冲突的情况。
            *   当会话成功配对 (传卡端和收卡端都加入) 时，向双方发送 `session_paired` 消息。
            *   实现一次性配对码 (OTP) 生成、验证、过期逻辑 (如果采用此方案)。
        *   处理客户端断开连接对会话的影响：
            *   从会话中移除断开的客户端。
            *   通知会话中剩余的客户端 `peer_disconnected`。
            *   更新会话状态，可能终止会话。
        *   设置会话不活动超时。
    *   **最佳实践：**
        *   使用并发安全的数据结构管理会话。
        *   会话ID应具有足够的随机性和长度以防止猜测。
        *   配对码应有时效性且一次性使用。
        *   清晰定义会话的生命周期状态 (e.g., `WaitingForPairing`, `Paired`, `Terminated`)。
3.  **APDU 消息中继逻辑 (手册 3.4)：**
    *   **负责人：** 后端开发者
    *   **任务：**
        *   实现处理 `apdu_upstream` (来自收卡端) 和 `apdu_downstream` (来自传卡端) 消息的逻辑。
        *   验证消息发送方是否属于其声明的 `sessionId` 和角色。
        *   根据 `sessionId` 查找配对的另一端客户端。
        *   将 APDU 载荷转发给目标客户端 (消息类型如 `apdu_to_card`, `apdu_from_card`)。
        *   处理目标客户端已掉线的情况 (向源客户端返回错误或状态更新)。
    *   **最佳实践：**
        *   中继逻辑应尽可能快，避免不必要的磁盘 I/O 或复杂计算。
        *   APDU 载荷作为透传数据，服务器不解析其内容（除非实现了基于服务器的 APDU 校验或端到端加密的辅助功能）。
        *   考虑使用 Go Channels 在不同 Goroutine 之间安全地传递消息。
4.  **API / 消息协议实现 (服务器端) (手册 3.5)：**
    *   **负责人：** 后端开发者
    *   **任务：**
        *   为所有定义的消息类型（客户端->服务器，服务器->客户端）创建对应的 Go 结构体。
        *   实现消息的序列化 (Go struct -> JSON string) 和反序列化 (JSON string -> Go struct)。
        *   确保服务器能正确处理所有定义的入站消息，并能正确构造和发送所有定义的出站消息。
    *   **最佳实践：**
        *   使用 `encoding/json` 标准库。
        *   对所有入站消息的必要字段进行严格校验（格式、类型、存在性）。
5.  **服务器端安全层实现 (基础部分) (手册 2.2, 2.6, 2.7)：**
    *   **负责人：** 后端开发者、安全工程师
    *   **任务：**
        *   **强制 WSS：** 配置服务器只接受 WSS (TLS) 连接。在 Gin 中，这意味着 HTTP 服务器需要配置 TLS 证书。WebSocket 升级请求会通过这个安全的 HTTP 服务器。
        *   **输入验证：** 对所有通过 WebSocket 接收到的消息进行严格的输入验证 (不仅仅是 JSON 解析，还包括业务逻辑层面的数据有效性)。
        *   **错误处理：** 实现健壮的错误处理机制，向客户端返回通用错误信息，避免泄露敏感的内部细节。
        *   **基础日志记录 (元数据)：** 实现连接、断开、注册、会话事件、APDU 中继元数据 (方向、长度、sessionId，不含APDU内容)、错误的日志记录。
    *   **最佳实践：**
        *   使用有效的、由可信 CA 签发的 SSL/TLS 证书。
        *   集成到现有的 Gin 中间件进行一部分输入验证或错误处理。
        *   遵循数据最小化原则，不记录不必要的敏感信息。

---

**阶段二：安全性增强与高级功能**

1.  **端到端 APDU 加密支持 (服务器中继) (手册 2.3)：**
    *   **负责人：** 后端开发者 (配合客户端团队)
    *   **任务：**
        *   虽然加密解密在客户端进行，但服务器消息协议可能需要调整以支持传输加密后的 APDU 载荷。
        *   服务器仅作为加密数据的中继，不持有密钥，不解密内容。
    *   **最佳实践：**
        *   确保服务器不会意外修改或损坏加密载荷。
        *   如果需要服务器验证消息完整性（在不知道密钥的情况下），可能需要客户端额外发送一个 HMAC，但这会增加复杂性。GCM 模式本身已包含认证。
2.  **速率限制与 DoS 防护 (手册 2.6)：**
    *   **负责人：** 后端开发者、运维/安全工程师
    *   **任务：**
        *   对客户端连接请求频率、消息发送频率、会话创建频率实施速率限制。
        *   可以使用类似 `golang.org/x/time/rate` 的库。
        *   集成到 Gin 中间件层面或 WebSocket 连接处理逻辑中。
    *   **最佳实践：**
        *   基于 IP 地址、会话 ID 或其他客户端标识进行速率限制。
        *   配置合理的阈值，避免影响正常用户。
        *   考虑使用专业的 WAF (Web Application Firewall) 服务。
3.  **详细日志记录与监控 (手册 3.7)：**
    *   **负责人：** 后端开发者、运维工程师
    *   **任务：**
        *   **日志内容细化：** 确保所有关键事件和错误都被恰当记录。
        *   **日志级别管理：** 允许通过配置调整日志级别。
        *   **监控指标集成：**
            *   暴露 Prometheus 指标：活动连接数、活动会话数、消息吞吐量、错误率等。
            *   可以使用 `github.com/prometheus/client_golang`。
            *   在 Gin 中添加 `/metrics` 端点。
        *   **告警设置：** 与监控系统集成，当关键指标异常或错误率过高时发送告警。
    *   **最佳实践：**
        *   结构化日志 (例如 JSON 格式)，方便机器解析和分析。
        *   确保日志不包含敏感数据，特别是 APDU 内容。
        *   监控指标应能反映系统的健康状况和性能瓶颈。
4.  **客户端状态同步 (status_update_to_server, peer_status_update) (手册 3.5)：**
    *   **负责人：** 后端开发者
    *   **任务：**
        *   实现处理客户端发送的 `status_update_to_server` 消息。
        *   根据需要，将这些状态更新（例如 `CARD_CONNECTED`, `CARD_REMOVED`）转发给配对的客户端，消息类型为 `peer_status_update`。
    *   **最佳实践：**
        *   明确哪些状态需要转发，避免不必要的网络流量。
        *   状态码应标准化。

---

**阶段三：测试、优化与部署**

1.  **单元测试与集成测试 (手册 5.4)：**
    *   **负责人：** 后端开发者、QA 工程师
    *   **任务：**
        *   为核心逻辑（会话管理、APDU 路由、消息处理）编写单元测试。使用 Go 的 `testing` 包。
        *   编写集成测试，模拟 WebSocket 客户端与服务器进行交互，验证整个消息流程。
    *   **最佳实践：**
        *   测试覆盖率应达到项目标准。
        *   Mock 外部依赖 (如 Redis，如果使用)。
2.  **性能测试与优化 (手册 5.1)：**
    *   **负责人：** 后端开发者、性能工程师
    *   **任务：**
        *   进行压力测试，模拟大量并发连接和高频消息，评估服务器的吞吐量、延迟和资源消耗。
        *   使用 Go pprof 等工具进行性能分析，找出瓶颈并进行优化。
    *   **最佳实践：**
        *   关注 Goroutine 的使用和管理，避免泄露。
        *   优化内存分配和GC。
        *   测试场景应尽可能接近真实用户行为。
3.  **部署注意事项 (手册 3.8)：**
    *   **负责人：** 运维工程师、后端开发者
    *   **任务：**
        *   **容器化：** 创建 Dockerfile，将 Go 应用打包成 Docker 镜像。
        *   **配置管理：** 确保 Viper 能够从环境变量或配置文件加载不同环境的配置 (数据库、Redis、TLS 证书路径等)。
        *   **水平扩展准备 (如果使用 Redis for Socket.IO adapter 类似机制)：**
            *   如果期望未来支持多节点部署以实现高可用和负载均衡，并且 WebSocket 连接需要在不同实例间路由或同步状态，需要考虑类似 `socket.io-redis-adapter` 的机制。对于纯 Go WebSocket，可能需要自行实现或寻找支持集群的 WebSocket 解决方案，或者依赖负载均衡器的粘性会话。
            *   如果会话状态完全由 Redis 管理，那么应用服务器本身可以是无状态的，更容易水平扩展。
        *   **CI/CD 流水线：** 建立或更新 CI/CD 流程，实现自动化构建、测试和部署。
    *   **最佳实践：**
        *   遵循十二因子应用原则。
        *   使用 Kubernetes 或类似的容器编排平台进行部署和管理。
        *   配置健康检查端点，供负载均衡器使用。

---

**通用最佳实践 (贯穿所有阶段)：**

*   **代码质量：**
    *   遵循 Go 语言的最佳实践和编码规范 (`go fmt`, `go vet`, `golangci-lint`)。
    *   编写清晰、可维护、文档充分的代码。
    *   进行代码审查 (Code Review)。
*   **错误处理：**
    *   在 Go 中，显式处理错误是核心。避免忽略错误。
    *   使用 `errors.Is` 和 `errors.As` 进行错误判断和包装。
*   **并发安全：**
    *   特别注意共享数据的并发访问，使用互斥锁 (`sync.Mutex`, `sync.RWMutex`)、Channels 或原子操作 (`sync/atomic`) 保护。
*   **配置外部化：**
    *   所有可配置项（端口、超时、密钥、第三方服务地址等）都应通过配置文件或环境变量进行管理，而不是硬编码。
*   **文档：**
    *   更新项目文档，包括 API 接口说明、架构设计、部署指南。

**与 Android 客户端团队的协作：**

*   **早期 API 协议对齐：** 确保双方对消息格式、事件名称理解一致。
*   **联调计划：** 尽早安排联调，逐步测试各个交互场景。
*   **问题反馈与追踪：** 使用统一的缺陷管理系统。

这个计划提供了一个相对全面的服务器端开发路线图。根据团队的实际情况和资源，可以调整各个任务的优先级和并行度。在开发过程中，持续关注安全性和性能将是至关重要的。
