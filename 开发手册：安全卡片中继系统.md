
---

**开发手册：安全卡片中继系统**
**版本： 2.0**
**日期： 2025年6月2日**

---

**第零章：术语与约定**

-   **用户 (User):** 系统的注册账户持有人。
-   **客户端ID (clientID):** 用户每次成功登录一个设备实例后，由服务器下发或客户端在服务器指导下生成的唯一标识符，代表一个活动的设备会话。
-   **用户ID (userID):** 用户账户的唯一标识符。
-   **传卡端 (Transmitter):** 用户选择的角色，手机App通过NFC连接真实银行卡，负责读取卡片信息并通过服务器中继。
-   **收卡端 (Receiver):** 用户选择的角色，手机App通过HCE模拟银行卡与真实POS机交互，或直接模拟POS终端（若支持）。
-   **会话 (Session):**
  * **角色会话 (Role Session):** 一个`clientID`被指定为特定角色（传卡端/收卡端）的活动状态。
  * **交易会话 (Transaction Session):** 一次完整的支付交互过程，关联一个传卡端和一个收卡端。
-   **BifroMQ:** 一款高性能的分布式MQTT消息队列遥测传输协议实现，用作本系统的实时消息代理。
-   **Gin:** 一个用Go语言编写的高性能HTTP Web框架，用于构建服务器端API。
-   **Vue Admin:** 基于Vue.js的管理后台前端解决方案，与Gin后端API配合进行系统管理。
-   **Flutter:** 由Google开发的开源UI软件开发工具包，用于为移动端（iOS和Android）构建高性能、高保真的应用程序。
-   **JWT:** JSON Web Token，用于身份验证和授权。
-   **HCE:** Host Card Emulation，主机卡模拟技术。
-   **APDU:** Application Protocol Data Unit，应用协议数据单元，支付卡与终端之间交互的指令和响应。
-   **NFC:** Near Field Communication，近场通信技术。
-   **Redis Key 约定:** `{scope}:{entity_id}:{attribute}` 例如: `user_roles:{userID}:transmitter_client_id`。建议对Key的命名规则做更详细的分类，如：`cfg:` (配置), `sts:` (状态), `sess:` (会话), `lock:` (分布式锁) 等。
-   **时间戳:** 除非特别说明，所有时间戳均为UTC时间的ISO 8601格式字符串 (例如: `"2025-06-01T10:00:00.123Z"`)。
-   **API版本控制:** 所有API接口路径均包含版本号，例如 `/api/v1/...`。

---

**第一章：系统概述与核心组件**

-   **1.1. 系统目标:** 允许用户通过一台“传卡端”手机（通过NFC连接到物理银行卡）和一台“收卡端”手机（模拟银行卡通过HCE与POS机交互，或模拟POS终端），在中央服务器的协调和全面监控下，安全、实时地完成支付卡信息的端到端加密中继。
-   **1.2. 核心组件:**
  * **客户端应用程序 (Flutter):** 单一代码库，根据用户选择运行于“传卡端”或“收卡端”模式。
    * **模块：** 用户界面 (UI/UX)、认证管理、角色管理、NFC交互 (物理卡读写/HCE模拟)、BifroMQ实时通信、本地安全存储、事件追踪与上报、端到端加密处理（若适用）。
  * **服务器端基础设施:**
    * **API服务 (Gin - Go语言):**
      * **认证服务:** 处理用户注册、登录、JWT签发与校验。
      * **角色与会话管理服务:** 管理用户当前活动的角色、角色对应的活动设备`clientID`，处理角色“挤下线”逻辑，管理交易会话生命周期。
      * **事件处理服务:** 消费客户端通过API或MQTT（间接）上报的事件，更新Redis中的实时状态，并将事件记录到审计日志。
      * **APDU中继协调服务:** 协调APDU在交易会话中的安全中继，但不直接处理APDU内容本身（内容由MQTT传输）。
    * **管理后台 (Vue Admin):** 通过Gin API与后端交互，用于用户管理、设备管理、日志查看、系统监控等。
    * **BifroMQ Broker:** 实时消息队列，支持MQTT v5特性（如会话管理、用户属性、错误报告）。负责客户端之间状态同步消息和APDU数据的实时、安全传输。
    * **状态同步服务 (可作为API服务的一部分或独立微服务):** 在同一`userID`下配对的传卡端和收卡端之间，通过BifroMQ中继相关的实时状态更新。
    * **Redis集群:** 用于缓存：用户登录会话JWT（或其吊销列表）、用户活动角色、客户端实时状态（当前屏幕、NFC/HCE状态等）、交易会话详情、临时中继数据。
    * **持久化数据库 (例如 PostgreSQL, MySQL):** 存储用户账户信息、设备登录历史、详细的审计日志（按时间顺序记录的用户全部操作）、交易记录。
    * **(强烈建议) API网关 (例如 Kong, Apache APISIX,或云服务商提供):** 统一管理对内服务的HTTP API接口，提供安全（WAF、TLS终止）、限流、监控、请求路由、认证聚合。
-   **1.3. 技术栈选型:**
  * **客户端:** Flutter
  * **服务器端API:** Go (Gin框架)
  * **服务器端管理后台:** Vue.js (例如 Gin Vue Admin 模板)
  * **MQTT Broker:** BifroMQ (支持集群部署)
  * **缓存:** Redis (推荐使用Redis Sentinel或Cluster以保证高可用)
  * **数据库:** PostgreSQL (推荐) 或 MySQL
-   **1.4. 安全原则:**
  * **通信安全:** 所有外部通信强制使用TLS 1.2+ (HTTPS, MQTTS)。
  * **认证授权:** 使用JWT进行API和BifroMQ连接认证。BifroMQ需配置JWT认证插件。
  * **数据最小化与保护:**
    * 服务器端不存储原始PAN（主账号）、完整磁道数据等敏感银行卡信息。APDU仅做安全中继，不在服务器端解密（若客户端已加密）。
    * 考虑对APDU流进行端到端加密，密钥由建联成功的收发双方协商（例如通过一次性的安全API通道），服务器仅作透传。
    * 数据库中敏感信息（如用户邮箱）应加密存储。
  * **访问控制:** BifroMQ主题访问权限采用最小权限原则 (ACLs)，基于`userID`和`clientID`进行细粒度控制。
  * **输入校验:** 所有客户端输入（包括通过MQTT接收的数据，若服务器需要解析其内容）在服务器端均需进行严格校验和净化。
  * **依赖安全:** 定期扫描客户端和服务端依赖库，及时修复已知漏洞。
  * **日志审计:** 全面记录关键操作和安全事件，确保日志不可篡改。
-   **1.5. 系统架构图 (建议补充):**
  * 建议在此处添加一幅高层系统架构图，清晰展示各组件及其交互关系。

---

**第二章：用户认证与设备注册**

-   **2.1. 数据结构定义:**
  * 数据库 (DB): `users` 表 (用户信息表)
    * `user_id` (UUID, 主键)
    * `email` (VARCHAR, 唯一, 索引) - 考虑加密存储
    * `password_hash` (VARCHAR) - 使用强哈希算法 (如 Argon2, scrypt, bcrypt)
    * `status` (VARCHAR, e.g., "active", "suspended", "pending_verification") - 新增用户状态
    * `created_at` (TIMESTAMPTZ)
    * `updated_at` (TIMESTAMPTZ)
  * 数据库 (DB): `user_devices_log` 表 (用户设备登录日志表)
    * `log_entry_id` (BIGSERIAL, 主键)
    * `user_id` (UUID, 外键关联 `users.user_id`)
    * `client_id` (VARCHAR, 索引) - 本次登录会话的客户端ID
    * `device_fingerprint` (VARCHAR, 可选, 索引) - 更持久的设备唯一标识 (如IMEI哈希, Android ID等，需注意隐私合规和用户授权)
    * `device_model` (VARCHAR) - 例如："iPhone 15 Pro", "Pixel 8"
    * `device_os` (VARCHAR) - 例如："iOS 17.1", "Android 14"
    * `app_version` (VARCHAR) - 例如："1.0.1"
    * `ip_address` (INET) - 登录时IP
    * `user_agent` (TEXT, 可选) - 客户端HTTP请求的User-Agent
    * `login_at` (TIMESTAMPTZ) - 本次登录时间
    * `logout_at` (TIMESTAMPTZ, 可空) - 本次登出或被踢下线时间
    * `logout_reason` (VARCHAR, 可空) - 例如："user_logout", "kicked_by_new_login", "jwt_expired", "session_revoked"
  * Redis:
    * `jwt_active:{userID}:{jti}` (STRING): 用于存储活跃的JWT ID，并可用于主动吊销。 Value: `clientID` 或 `true`。TTL: JWT有效期。
    * `jwt_blacklist:{jti}` (STRING): (备选方案) 用于存储已作废的JWT ID。Value: "revoked"。TTL: 设置为原JWT的剩余有效期。 *选择一种机制即可，主动记录活跃JWT更易于管理一个用户的所有会话。*
-   **2.2. 用户注册流程:**
  1.  客户端 (Flutter App) 操作: 用户在App注册界面输入邮箱、密码、确认密码。
  2.  客户端API调用: `POST /api/v1/auth/register` (HTTPS)
  3.  请求体 (Request Body):
      ```json
      {
        "email": "user@example.com",
        "password": "securePassword123",
        "device_info": { // 设备信息，用于首次注册记录
          "device_model": "Pixel 8 Pro",
          "device_os": "Android 14",
          "app_version": "1.0.0",
          "device_fingerprint": "optional_persistent_device_id_hash" // 注意哈希处理
        }
      }
      ```
  4.  服务器 (Gin API - 认证服务) 逻辑:
      a.  输入校验: 校验邮箱格式、密码强度（例如：长度、字符类型组合、是否为常见弱密码）。
      b.  查重: 检查email是否已在`users`表中存在。若存在，返回错误。
      c.  创建用户: 生成`user_id` (UUID)。对password进行哈希处理。
      d.  存储用户: 将`user_id`, `email` (加密后), `password_hash`, `status` ("active" 或 "pending_verification" 如果需要邮件验证), `created_at`, `updated_at`存入`users`表。
      e.  记录审计日志: 调用审计日志服务，记录用户注册事件。
      f.  响应: 返回201 Created状态码和成功信息（例如，仅`user_id`和`email`），或相应的错误码及信息。不应立即返回JWT，注册后应引导用户登录。
-   **2.3. 用户登录流程:**
  1.  客户端 (Flutter App) 操作: 用户在App登录界面输入邮箱、密码。
  2.  客户端API调用: `POST /api/v1/auth/login` (HTTPS)
  3.  请求体 (Request Body):
      ```json
      {
        "email": "user@example.com",
        "password": "securePassword123",
        "device_info": { // 每次登录都上报，用于记录和潜在的风险评估
          "device_model": "Pixel 8 Pro",
          "device_os": "Android 14",
          "app_version": "1.0.0",
          "device_fingerprint": "optional_persistent_device_id_hash"
        }
      }
      ```
  4.  服务器 (Gin API - 认证服务) 逻辑:
      a.  输入校验: 校验邮箱和密码格式。
      b.  查找用户: 根据`email`从`users`表查找用户。若用户不存在或`status`非激活，返回错误。
      c.  校验密码: 将请求中的password与存储的`password_hash`进行比对。若不匹配，返回错误（注意防范用户枚举攻击，错误信息应模糊）。
      d.  生成`clientID`: 为本次登录会话生成一个唯一的`clientID` (UUID)。
      e.  签发JWT:
      * Payload: `{"user_id": "...", "client_id": "...", "jti": "<unique_jwt_id>", "exp": "<timestamp_seconds>", "iss": "your_issuer_name", "aud": "your_audience"}`. `jti`是JWT的唯一标识符。
      * 使用安全的密钥（如RS256/ES256，密钥需妥善管理）进行签名。
      f.  记录设备日志: 在`user_devices_log`表中创建一条新的登录记录。
      g.  (可选，用于主动会话管理) 将`jti`或`clientID`存入Redis `jwt_active:{userID}:{jti}`。
      h.  记录审计日志: 记录用户登录成功事件。
      i.  响应: 返回200 OK状态码及以下JSON数据：
      ```json
      {
        "jwt_token": "your_jwt_token_here",
        "user_id": "retrieved_user_id_from_db",
        "client_id": "generated_client_id_for_this_session",
        "token_type": "Bearer",
        "expires_in": 3600 // JWT有效期秒数
      }
      ```
      j.  若登录失败，返回相应的HTTP错误状态码 (如401 Unauthorized)和错误信息。
-   **2.4. 客户端JWT与标识符存储:**
  * 客户端 (Flutter) 必须安全地存储`jwt_token` (例如使用`flutter_secure_storage`)。
  * `user_id`和`client_id`也应被存储在App的安全内存或持久化存储中，供后续BifroMQ连接和API调用使用。
-   **2.5. 用户登出流程 (建议补充):**
  1.  客户端API调用: `POST /api/v1/auth/logout` (HTTPS, 携带JWT)
  2.  服务器 (Gin API - 认证服务) 逻辑:
      a.  验证JWT有效性。
      b.  从JWT中解析`jti`和`userID`.
      c.  从Redis `jwt_active:{userID}:{jti}` 中移除该`jti`，或将`jti`加入`jwt_blacklist:{jti}`。
      d.  更新`user_devices_log`中对应`clientID`的登出时间和原因。
      e.  记录审计日志。
      f.  响应200 OK。
  3.  客户端清除本地存储的JWT和会话信息。

---

**第三章：BifroMQ连接与角色管理**

-   **3.1. BifroMQ连接建立 (客户端 - Flutter):**
  1.  连接参数:
    * Broker地址: `mqtts://your-bifromq-broker.com:8883` (必须使用MQTTS，确保TLS证书有效)。
    * MQTT Client ID (协议级别): 使用登录时服务器下发的`clientID`。
    * Username: `clientID` (推荐) 或 `userID`。这取决于BifroMQ认证插件的配置。
    * Password: 使用登录时获取的`jwt_token`。
    * Clean Session: 通常设置为 `true` (MQTTv3.1.1) 或 `Clean Start` + `Session Expiry Interval = 0` (MQTTv5)。如果需要持久会话，需仔细设计。
    * MQTT Version: 明确使用MQTT v5以利用其高级特性。
  2.  BifroMQ Broker配置:
    * 必须配置认证插件 (例如，自定义插件或利用BifroMQ的可扩展性) 以：
      * 解析JWT。
      * 使用认证服务提供的公钥验证JWT签名。
      * 检查JWT是否过期 (`exp`)，颁发者 (`iss`)，受众 (`aud`)。
      * 检查JWT的`jti`是否在`jwt_blacklist`中或不在`jwt_active`中 (取决于所选登出机制)。
      * 验证通过后，插件应能将JWT中的`userID`和`clientID`与此MQTT连接关联起来（例如，通过MQTTv5用户属性），供后续ACL和业务逻辑使用。
    * 配置授权插件 (ACLs) 以实施最小权限原则，例如：
      * 客户端只能发布到 `client/{clientID}/...` 开头的主题。
      * 客户端只能订阅 `client/{clientID}/...` 开头的主题。
      * 服务器端组件有更广泛的权限。
  3.  Last Will and Testament (LWT - 遗嘱消息): 客户端在连接时设置。
    * Topic: `client/{clientID}/status`
    * Payload: `{"online": false, "timestamp_utc": "...", "reason": "connection_lost_unexpectedly"}`
    * QoS: 1 (至少一次送达保证)
    * Retain Flag: True (新订阅者能立刻获取最后状态)
  4.  成功连接后的操作 (Client `onConnected`回调):
      a.  发布上线状态:
      * Topic: `client/{clientID}/status`
      * Payload:
      ```json
      {
        "online": true,
        "timestamp_utc": "...",
        "device_info": {
          "device_model": "Pixel 8 Pro",
          "device_os": "Android 14",
          "app_version": "1.0.0"
        },
        "network_info": { // 可选，用于诊断
          "type": "WIFI", // "CELLULAR"
          "signal_strength_dbm": -55 // if available
        }
      }
      ```
      * QoS: 1, Retain Flag: True.
      b.  订阅必要主题:
      * `client/{clientID}/control/#`: 用于接收服务器的控制指令。
      * `client/{clientID}/sync/#`: 用于接收来自已配对的对端设备的状态同步事件。
      * `client/{clientID}/transaction/{transactionID}/apdu/down`: 用于在交易会话中接收服务器转发的APDU指令/响应。通常在交易开始后动态订阅此主题或其通配符版本 `client/{clientID}/transaction/+/apdu/down`。
-   **3.2. Redis数据结构定义 (角色与客户端状态):**
  * `user_roles:{userID}` (HASH): 存储用户当前激活的角色及其对应的`clientID`。
    * `transmitter_client_id`: (STRING)
    * `transmitter_set_at_utc`: (STRING ISO8601 Timestamp)
    * `receiver_client_id`: (STRING)
    * `receiver_set_at_utc`: (STRING ISO8601 Timestamp)
  * `client_state:{clientID}` (HASH): 存储每个活动`clientID`的详细实时状态。
    * `user_id`: (STRING)
    * `role`: (STRING) "transmitter", "receiver", "none", "pending_role_selection".
    * `device_model`, `device_os`, `app_version`: (STRING)
    * `ip_address`: (STRING) MQTT连接源IP (BifroMQ提供给后端服务)。
    * `current_screen`: (STRING) App当前主要界面。
    * `last_event_timestamp_utc`: (STRING ISO8601 Timestamp)
    * `mqtt_connected_at_utc`: (STRING ISO8601 Timestamp)
    * `is_online`: ("true" / "false")
    * (传卡端专属状态 - `role`为`transmitter`时有效):
      * `nfc_status_transmitter`: (STRING) "idle", "card_detected", "card_removed", "nfc_error", "reading_card".
      * `card_details_hash_transmitter`: (STRING, 可选) 卡片非敏感信息（如ATR）的哈希。
      * `card_type_guess_transmitter`: (STRING)
      * `card_present_since_utc_transmitter`: (STRING ISO8601 Timestamp)
      * `card_absent_since_utc_transmitter`: (STRING ISO8601 Timestamp)
    * (收卡端专属状态 - `role`为`receiver`时有效):
      * `hce_status_receiver`: (STRING) "idle", "active_waiting_for_pos", "pos_connected_interacting", "hce_deactivated", "hce_error".
      * `last_pos_interaction_utc_receiver`: (STRING ISO8601 Timestamp)。
-   **3.3. 角色选择与“挤下线”逻辑:**
  1.  客户端UI (Flutter): 成功登录并建立BifroMQ连接后，App显示角色选择界面。
  2.  客户端操作 (用户选择“传卡端”为例):
      a.  App发布MQTT消息：
      * Topic: `client/{clientID}/control/set_role_request`
      * Payload:
      ```json
      {
        "user_id": "current_user_id_from_login",
        "requested_role": "transmitter",
        "request_id": "client_generated_uuid_for_this_request",
        "timestamp_utc": "..."
      }
      ```
      * QoS: 1.
  3.  服务器 (角色与会话管理服务 - 订阅 `client/+/control/set_role_request` 或通过BifroMQ的规则引擎/钩子转发到API):
      a.  解析与验证: 从MQTT主题中提取`clientID`。从Payload中提取`userID`, `requested_role`, `request_id`。
      b.  身份验证: **关键安全步骤**: 验证Payload中的`userID`是否与当前MQTT连接（由`clientID`标识）认证的`userID`一致。BifroMQ的认证插件应能将此信息传递给后端。
      c.  记录审计日志: 记录收到角色设置请求的事件。
      d.  获取当前角色分配: 从Redis查询 `user_roles:{userID}`。
      e.  处理“挤下线”逻辑:
      * 若 `existing_role_holder_clientID` 存在且不等于当前请求的`clientID`：
      i.  通知被占用的客户端 (服务器发布MQTT消息)：
      * Topic: `client/{existing_role_holder_clientID}/control/role_revoked_notification`
      * Payload:
      ```json
      {
        "revoked_role": "transmitter",
        "reason": "role_taken_by_another_device",
        "kicked_by_client_id": "requesting_client_id",
        "kicked_by_device_info": { /* ... */ },
        "timestamp_utc": "..."
      }
      ```
      * QoS: 1.
      ii. 更新被占用客户端的状态 (服务器内部): 更新Redis `client_state`，（可选）吊销其JWT，更新`user_devices_log`。
      iii. 记录审计日志: 记录“踢下线”事件。
      f.  分配角色给请求客户端: 更新Redis `user_roles:{userID}` 和 `client_state:{clientID}`。
      g.  记录审计日志: 记录角色成功设置事件。
      h.  向请求客户端发送确认 (服务器发布MQTT消息)：
      * Topic: `client/{clientID}/control/set_role_response`
      * Payload:
      ```json
      {
        "request_id": "echo_back_client_request_id",
        "role_assigned": "transmitter",
        "status": "success",
        "timestamp_utc": "..."
      }
      ```
      * QoS: 1.
      i.  检查并通知对端设备配对状态 (Pairing Logic):
      * 若传卡端和收卡端均已设置，则互相通知对方的 `clientID`, 设备信息, 和当前状态。
      * Topic: `client/{clientID}/control/peer_status_notification` 和 `client/{peer_clientID}/control/peer_status_notification`
      * Payload示例 (通知传卡端关于收卡端):
      ```json
      {
        "peer_role": "receiver",
        "peer_client_id": "{current_receiver_clientID}",
        "peer_is_online": true, // 从client_state获取
        "peer_device_info": { /* ... */ },
        "peer_current_status": { /* ... */ },
        "timestamp_utc": "..."
      }
      ```
      * 记录审计日志: 记录配对成功事件。
  4.  客户端 (Flutter) 处理 `set_role_response`, `role_revoked_notification`, `peer_status_notification` 并更新UI和本地状态。

---

**第四章：设备间实时状态同步 (同userID下的传卡端与收卡端)**

-   **4.1. 同步原则:** 当任一端状态变化时，向服务器的指定BifroMQ主题发布“状态更新事件”。服务器的“状态同步服务”（可能集成在API服务中，或是一个独立的微服务监听BifroMQ）接收此事件，验证，更新Redis `client_state`，然后将处理/筛选后的事件版本转发给配对的另一端设备。
-   **4.2. 客户端状态更新事件发布主题 (Client -> Server via BifroMQ):** `client/{clientID}/event/state_update` (QoS: 1)
-   **4.3. 服务器状态同步服务订阅主题 (BifroMQ -> Server):** `client/+/event/state_update` (或配置BifroMQ规则引擎将此类消息推送到特定API端点)
-   **4.4. 对端状态同步下发主题 (Server -> Client via BifroMQ):** `client/{peer_clientID}/sync/peer_state_update` (QoS: 1)
-   **4.5. 传卡端 (Transmitter) 特有状态与事件:** (示例：卡片检测)
  * 事件类型 (event_type): `nfc_transmitter_status_change`
    1.  检测到卡片 (Card Detected):
      * 客户端 (Flutter - 传卡端) 操作: `flutter_nfc_kit` (或类似库) 的 `onTagDiscovered` 回调被触发。
      * 客户端发布 Payload 到 `client/{clientID}/event/state_update`:
          ```json
          {
            "event_type": "nfc_transmitter_status_change",
            "status_details": {
              "nfc_status": "card_detected",
              "card_info": {
                "atr_hex": "...", // 卡片ATR
                "uid_hex": "...", // 卡片UID (若可读且合规)
                "tech_list": ["NfcA", "IsoDep"],
                "type_guess": "Visa" // 基于ATR或内置库的猜测
              }
            },
            "timestamp_utc": "..."
          }
          ```
      * 服务器 (状态同步服务) 处理:
        a.  记录原始事件到审计日志。
        b.  更新Redis `client_state:{transmitter_clientID}`。
        c.  从`user_roles:{userID}`查找已配对的`receiver_clientID`。
        d.  若`receiver_clientID`存在且在线:
        * 服务器发布到 `client/{receiver_clientID}/sync/peer_state_update`:
        ```json
        {
          "source_peer_role": "transmitter",
          "event_type": "nfc_status_update",
          "data": {
            "status": "card_detected",
            "card_type_guess": "Visa",
            "detected_at_utc": "..."
          },
          "server_publish_timestamp_utc": "..."
        }
        ```
      * 客户端 (Flutter - 收卡端) 接收处理: 更新UI。
  * 其他传卡端事件: 卡片持续放置, 卡片被移开, NFC错误/关闭 (类似流程)。
-   **4.6. 收卡端 (Receiver) 特有状态与事件:** (示例：HCE激活)
  * 事件类型 (event_type): `hce_receiver_status_change`
    1.  HCE已激活，等待POS连接:
      * 客户端 (Flutter - 收卡端) 操作: 用户启动“收卡模式”，HCE服务开始。
      * 客户端发布 Payload 到 `client/{clientID}/event/state_update`:
          ```json
          {
            "event_type": "hce_receiver_status_change",
            "status_details": {
              "hce_status": "active_waiting_for_pos"
            },
            "timestamp_utc": "..."
          }
          ```
      * 服务器和对端客户端（传卡端）进行类似的状态更新和UI提示。
  * 其他收卡端事件: POS机已连接交互, HCE已停用, HCE错误 (类似流程)。
-   **4.7. 通用状态与事件 (适用于传卡端和收卡端):**
  * 事件类型 (event_type): `ui_state_change` (应用界面或前后台状态变化)
    * Payload示例: `{"current_screen_name": "TransactionSummaryPage", "app_lifecycle_status": "in_foreground"}`
    * 服务器选择性同步给对端。
  * 事件类型 (event_type): `device_health_change` (设备健康状态变化)
    * Payload示例: `{"battery_level_percent": 15, "network_type": "CELLULAR"}`
    * 服务器选择性同步给对端，例如低电量警告。

---

**第五章：“全知全能”服务器 - 事件审计与日志记录**

-   **5.1. 核心原则:** 服务器必须以线性、时序的方式，记录下每个用户的几乎所有可观察的操作和系统事件。日志应包含足够的信息用于问题排查、安全审计、用户行为分析和系统监控。使用结构化日志（如JSON格式）。
-   **5.2. 审计日志数据库表: `user_activity_audit_log`**
  * `log_id` (BIGSERIAL, 主键)
  * `timestamp_utc` (TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP, 强索引)
  * `user_id` (UUID, 外键关联 `users.user_id`, 索引, 可空)
  * `client_id` (VARCHAR, 索引, 可空)
  * `source_ip_address` (INET, 可空)
  * `device_model`, `device_os`, `app_version` (VARCHAR, 可空)
  * `trace_id` (UUID, 可选, 索引) - 用于关联一次完整操作（跨多个服务）的追踪ID。
  * `event_source_type`: (ENUM: "CLIENT_API_REQUEST", "CLIENT_MQTT_MESSAGE", "SERVER_INTERNAL_PROCESS", "BIFROMQ_HOOK")
  * `event_category`: (VARCHAR, 索引) - 例如: "AUTHENTICATION", "ROLE_MANAGEMENT", "NFC_INTERACTION", "TRANSACTION_LIFECYCLE", "APDU_RELAY", "SYSTEM_ERROR"
  * `event_type`: (VARCHAR, 索引) - 例如: "user_login_success", "set_role_request_received", "card_detected_event"
  * `event_details`: (JSONB) - 存储事件相关的详细数据（脱敏后）。
  * `related_transaction_id` (UUID, 外键关联 `transactions` 表, 可空, 索引)
  * `is_sensitive`: (BOOLEAN DEFAULT FALSE)
  * `processing_status`: (VARCHAR, 可选, e.g., "SUCCESS", "FAILURE", "PENDING") - 事件处理结果。
-   **5.3. 日志记录点 (服务器端 - Gin API, BifroMQ 钩子/监听器):**
  * **认证服务:** 所有 /auth/ API的请求与响应（脱敏密码），JWT签发/校验。
  * **角色与会话管理服务:** 角色设置请求，挤下线操作，配对通知。
  * **BifroMQ 钩子 (Hooks) 或服务器端BifroMQ消息监听器:**
    * 客户端连接/断开 (含原因、IP、认证结果)。
    * 服务器接收/发布的所有MQTT消息 (主题、Payload摘要或脱敏后内容、QoS)。
  * **状态同步服务:** 收到的原始状态更新事件，转发给对端的同步事件。
  * **APDU中继服务 (详见第六章):** APDU流转记录 (脱敏或摘要)。
  * **Gin框架层面:** 所有API请求的通用日志（请求路径、方法、状态码、处理时长、IP）。
  * **系统内部错误和安全事件。**
-   **5.4. 日志信息丰富化 (Log Enrichment):** 自动关联`userID`, 设备信息, `current_role`等上下文到日志条目。
-   **5.5. 日志管理与查询:**
  * 采用标准日志级别 (DEBUG, INFO, WARNING, ERROR, CRITICAL)。
  * 考虑将日志输出到专门的日志管理系统 (如 ELK Stack, Splunk, Grafana Loki) 以便高效查询、分析和告警。

---

**第六章：交易流程与APDU中继**

-   **6.1. 交易会话发起 (建议):**
  1.  **条件确认:** 传卡端检测到卡片，收卡端HCE激活并等待POS。双方状态均就绪。
  2.  **请求创建:** 任一端（例如收卡端检测到POS机尝试通讯后）通过API向服务器请求创建交易会话: `POST /api/v1/transactions`
    * 请求体: `{"transmitter_client_id": "...", "receiver_client_id": "..."}` (由客户端从本地状态获取，服务器会校验其有效性)
  3.  **服务器处理:**
    * 验证`clientID`有效性及其角色。
    * 生成唯一的`transactionID` (UUID)。
    * 在Redis中创建交易会话记录: `transaction_session:{transactionID}` (HASH)
      * `transmitter_client_id`, `receiver_client_id`, `status` ("pending", "active", "completed", "failed"), `created_at_utc`, `last_activity_utc`.
    * 在持久化数据库`transactions`表中创建记录。
    * 响应客户端`transactionID`。
    * 通过BifroMQ向双方客户端下发交易开始指令，包含`transactionID`。
      * Topic: `client/{clientID}/control/transaction_started`
      * Payload: `{"transaction_id": "...", "status": "pending_apdu_exchange"}`
  4.  **客户端准备:** 客户端收到`transaction_started`后，动态订阅APDU相关主题，并进入APDU收发状态。
-   **6.2. APDU上报与下发主题 (BifroMQ):**
  * 客户端 -> 服务器: `client/{clientID}/transaction/{transactionID}/apdu/up`
    * Payload: `{"sequence_number": 1, "apdu_hex": "00A40400...", "source_role": "transmitter" | "receiver", "timestamp_utc": "..."}`
  * 服务器 -> 客户端: `client/{peer_clientID}/transaction/{transactionID}/apdu/down`
    * Payload: `{"sequence_number": 1, "apdu_hex": "00A40400...", "target_role": "receiver" | "transmitter", "server_process_time_ms": 10, "timestamp_utc": "..."}`
-   **6.3. 服务器APDU中继逻辑 (可由独立微服务或Gin API内的模块处理):**
  * 订阅 `client/+/transaction/+/apdu/up`。
  * 验证`transactionID`有效性，`clientID`与交易会话记录是否匹配。
  * 记录每一条APDU的流向和内容（可考虑部分脱敏或仅记录长度/哈希，除非调试需要）到审计日志，关联`transactionID`。
  * 将APDU（原样或重新封装）转发给交易会话中的另一方对应的`apdu/down`主题。
  * 监控APDU交互序列和超时（例如，若一方发送APDU后长时间未收到响应）。可设定整体交易超时。
-   **6.4. 交易结束:**
  * **结束条件:**
    * APDU交互正常结束 (例如，卡片返回`9000`成功状态码，POS返回交易接受/拒绝)。
    * 任一客户端主动中止交易 (上报事件)。
    * 发生错误 (NFC错误、HCE错误、网络中断超时)。
    * 服务器检测到超时。
  * **通知:** 客户端上报交易结束相关的事件或最终APDU。
  * **服务器处理:**
    * 更新Redis和持久化数据库中的交易会话状态（"completed_success", "completed_failure", "aborted_by_user", "timeout"）。
    * 记录交易结果和时长到审计日志。
    * 通过BifroMQ向双方客户端下发交易结束指令。
      * Topic: `client/{clientID}/control/transaction_ended`
      * Payload: `{"transaction_id": "...", "status": "completed_success", "details": "..."}`

---

**第七章：错误处理、安全加固与边缘场景**

-   **7.1. 网络问题:**
  * **客户端 (Flutter):** 实现BifroMQ和HTTP API的自动重连（带指数退避和抖动策略）。对幂等操作进行安全重试。
  * **服务器 (BifroMQ LWT):** LWT机制处理意外断连，服务器相应更新`client_state`并通知对端。
  * **心跳机制:** MQTT `keepAliveInterval` 和应用层心跳（若有必要）来检测死连接。
-   **7.2. 数据校验:**
  * **服务器 (Gin):** 对所有客户端API参数、BifroMQ消息（若服务器解析其内容）进行严格的格式、类型、范围和逻辑校验。使用Gin的验证器或类似机制。
  * **客户端 (Flutter):** 对用户输入进行初步校验，减轻服务器压力。
-   **7.3. 并发与竞态条件:**
  * **Redis操作原子性:** 关键操作（如角色设置、计数器更新）在Redis层面可使用Lua脚本或事务 (MULTI/EXEC) 保证原子性。
  * **乐观锁:** 对需要更新的共享资源（如交易状态），可考虑使用版本号或时间戳进行乐观锁控制。
-   **7.4. 安全加固 (补充):**
  * **API限流防刷:** 对登录、注册、验证码等敏感API进行速率限制 (基于IP、`userID`)。
  * **防范重放攻击:** 关键MQTT消息和API请求中使用一次性`request_id`或nonce，并在服务器端校验。JWT的`jti`也有此作用。
  * **WAF/IPS:** 在API网关或服务器入口部署Web应用防火墙和入侵防御系统。
  * **依赖库安全:** 定期使用工具扫描Flutter、Go、Vue及其各自的依赖库，及时更新修复已知漏洞。
  * **敏感配置管理:** 使用环境变量或专用的配置管理服务（如HashiCorp Vault）管理密钥、数据库密码等敏感信息，禁止硬编码。
  * **数据加密:** 传输层TLS强制，数据库敏感字段加密存储，考虑APDU端到端加密。
-   **7.5. 客户端奔溃恢复:** 客户端重启后，引导用户重新登录，重建BifroMQ连接，重新选择角色。服务器状态会相应更新。本地持久化应帮助恢复部分UI状态。
-   **7.6. 服务器故障与恢复 (高可用性):**
  * **BifroMQ集群:** 利用BifroMQ的集群能力保证消息服务高可用。
  * **Redis Sentinel/Cluster:** 保证缓存服务高可用。
  * **数据库主从复制与备份:** 实现数据冗余和灾难恢复能力。
  * **无状态应用服务 (Gin API):** Gin API服务应设计为无状态，便于水平扩展和故障切换。会话状态存储在Redis。
  * **容器化与编排 (如 Docker, Kubernetes):** 便于部署、扩展和管理服务。
-   **7.7. 系统监控与告警 (建议补充):**
  * **指标监控:** 监控关键性能指标 (KPIs)，如API响应时间、错误率、BifroMQ消息吞吐量、队列深度、服务器资源使用率 (CPU, 内存, 网络)。使用Prometheus/Grafana等工具。
  * **告警机制:** 对关键错误、服务不可用、性能瓶颈、安全事件设置实时告警通知运维团队。
-   **7.8. 客户端版本管理 (建议补充):**
  * 强制/推荐更新机制，以确保用户使用最新的安全补丁和功能。API可以根据`app_version`进行兼容性处理或提示更新。

---

**第八章：附录 (可选)**

-   **A.1. API接口详细定义 (Swagger/OpenAPI 规范链接或嵌入):**
  * 提供所有HTTP API的详细请求/响应格式、参数说明、错误码等。
-   **A.2. MQTT 主题与Payload结构详细定义:**
  * 汇总所有用到的MQTT主题及其消息体JSON结构。
-   **A.3. 状态码与错误代码表:**
  * 定义系统内部的错误代码及其含义，方便客户端统一处理和用户提示。
-   **A.4. 部署架构图 (建议补充):**
  * 更详细的部署图，展示服务器组件在物理或虚拟环境中的分布、网络区域、负载均衡器等。

---

**优化建议汇总 (除上述已融入的细节外):**

1.  **引入API网关:** 更强烈地推荐使用API网关，它能统一处理认证、限流、路由、监控、日志等横切关注点，简化Gin API服务的逻辑。
2.  **端到端加密APDU:** 为增强安全性，可以考虑在传卡端和收卡端之间对APDU流进行端到端加密。密钥可以在交易会话建立时通过安全的API通道协商。服务器仅透传加密后的APDU，不参与解密。
3.  **结构化日志与追踪ID:** 强制使用JSON等结构化日志格式，并引入分布式追踪ID（Trace ID），便于在复杂调用链中追踪和调试问题。
4.  **详细的部署和运维指南:** 针对BifroMQ集群、Gin服务集群、Redis Sentinel/Cluster、数据库高可用方案，补充相应的部署、监控、备份和故障演练指南。
5.  **安全性测试和渗透测试:** 定期进行安全代码审计和第三方渗透测试，确保系统安全性。
6.  **用户体验细节:**
  * 在网络不稳定或状态同步延迟时，客户端应有明确的加载或等待提示。
  * 错误提示应友好且易于理解，避免直接暴露技术细节。
  * “挤下线”通知应清晰告知用户原因和被哪台设备操作。
7.  **配置管理:** 所有可配置项（数据库连接串、JWT密钥、BifroMQ地址、第三方服务凭证等）应通过环境变量或配置文件管理，而不是硬编码在代码中。Go应用可以使用Viper等库管理配置。
8.  **完善的测试策略:** 包括单元测试（Go的`testing`包，Flutter的测试框架）、集成测试（测试服务间交互）、端到端测试。
9.  **文档中的图示:** 在“系统概述”、“部署架构”、“交易流程”等章节中加入架构图、序列图、流程图，能极大提升文档的可读性和易理解性。

---

希望这份经过微调和优化的文档能更好地满足您的需求！